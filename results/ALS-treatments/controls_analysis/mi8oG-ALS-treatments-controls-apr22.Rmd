---
title: "miRNAs-ALS-treatments-controls-apr22"
author: "César Esparza"
date: "2025-04-22"
output: html_document
---

```{r}
install.packages("rlang")
```


```{r}
install.packages("stringr")
install.packages("janitor")
install.packages("limma")


if (!requireNamespace("DESeq2", quietly=TRUE)) {
  BiocManager::install("DESeq2")
}


if (!requireNamespace("edgeR", quietly=TRUE)) {
  BiocManager::install("edgeR")
}

```

```{r}
library(rlang)
library(stringr)
library(tidyverse)
library(janitor)
library(DESeq2)
library(limma)
library(edgeR)
```



```{r}
# 1. Leer y limpiar nombres de columna -----------------------------
# ¿Por qué? Normalizar todos los nombres (reemplaza espacios, ":" y paréntesis).
df_raw <- read_tsv("/Users/cesaresparza/New_Desktop/UCSD/8OG/results/ALS-treatments/controls_analysis/miRNA_count.Q35.txt") %>%
  clean_names()
# Ahora la columna "pos:mut" es "pos_mut", y los totales "(PM+1MM+2MM)" son 
# p.ej. "trimmed_sod1_als_ipsc_..._1_pm_1mm_2mm".

colnames(df_raw)
```
```{r}
# 2.1. Crear un nuevo data.frame solo con las SNVs (quitando los PM)
df_snv <- df_raw %>%
  filter(pos_mut != "PM")

# 2.2. Verificación rápida:  
#     ¿Cuántas filas teníamos en el raw y cuántas quedan?
n_raw <- nrow(df_raw)
n_snv <- nrow(df_snv)
message("Filas totales: ", n_raw, 
        " → Filas sin PM: ", n_snv,
        " (eliminadas: ", n_raw - n_snv, ")")
```


```{r}
split_mutations <- function(df, mut_col = "pos_mut") {
  col_sym <- sym(mut_col)
  df %>% 
    separate_rows(!!col_sym, sep = ",") %>% 
    mutate(!!col_sym := str_trim(!!col_sym))
}

df_snv_split <- split_mutations(df_snv, "pos_mut")


```


```{r}
collapse_mutations <- function(df, mut_col = "pos_mut") {
  # 4.1. Identificar columnas de conteo puro (excluyendo totales PM+1MM+2MM)
  count_cols <- df %>% 
    select(starts_with("trimmed_")) %>% 
    select(-ends_with("_pm_1mm_2mm")) %>% 
    names()
  
  # 4.2. Agrupar por miRNA + mutación (posición:mut) y sumar los reads
  df %>%
    group_by(mi_rna_name, !!sym(mut_col)) %>%
    summarise(across(all_of(count_cols), sum), .groups = "drop") 
}

# Aplicar al df_snv_split (resultado de split_mutations)
df_collapsed <- collapse_mutations(df_snv_split, "pos_mut")

```


```{r}
df_collapsed
```
```{r}
# 1) Define las columnas de conteo puro:
count_cols <- df_collapsed %>%
  select(starts_with("trimmed_")) %>%
  select(-ends_with("_pm_1mm_2mm")) %>%
  names()
```


```{r}
# 2) Genera featureID y construye la matriz:
df_DE <- df_collapsed %>%
  mutate(
    pos_mut   = str_replace_all(pos_mut, ":", "_"),
    featureID = paste(mi_rna_name, pos_mut, sep = "_")
  ) %>%
  select(featureID, all_of(count_cols)) %>%
  column_to_rownames("featureID")

count_mat <- as.matrix(df_DE)


# 4) Forzar integer (requisito de edgeR)
mode(count_mat) <- "integer"

# Verifica que existe y no tiene NAs:
stopifnot(exists("count_mat"))
stopifnot(!any(is.na(count_mat)))

cat("Dimensions of count_mat:", dim(count_mat), 
    "(rows = variants, cols = samples)\n")
```


```{r}

sample_table <- tibble(sample = colnames(count_mat)) %>%
  # str_match devuelve una matriz: columna 1 = todo el match,
  # 2 = primer grupo (batch), 3 = segundo grupo (rep)
  mutate(
    tmp   = str_match(sample, "_rep(\\d+)_(\\d+)_"),
    batch = as.integer(tmp[,2]),
    rep   = as.integer(tmp[,3])
  ) %>%
  select(-tmp) %>%
  # si quieres tratarlas como factores
  mutate(
    batch = factor(batch),
    rep   = factor(rep)
  )

# Verificación
print(sample_table)
print(table(sample_table$batch))
```

```{r}
# ——————  Filtrar variantes outliers antes de armar el DGEList ——————
# 1) Calculo la suma de counts por variante (rowSums sobre count_mat)
variant_sums <- rowSums(count_mat)

# 2) Defino el umbral: p.ej. percentil 99
cutoff <- quantile(variant_sums, probs = 0.95)

# 3) Reporto cuántas variantes elimino
n_out <- sum(variant_sums > cutoff)
cat("Eliminando", n_out, "variantes (", 
    round(100 * n_out/length(variant_sums),1), 
    "%) con total >", round(cutoff,1), "lecturas\n")

# 4) Subconjunto el count_mat
keep_vars  <- names(variant_sums)[variant_sums <= cutoff]
count_mat   <- count_mat[keep_vars, , drop = FALSE]
```


```{r}
dge <- DGEList(counts = count_mat, samples = sample_table)
```

```{r}
dge
```



```{r}
# Requerimos al menos 0.5 CPM en al menos 2 muestras
keep <- filterByExpr(dge,
                     group = dge$samples$genotype,
                     min.count = 2,      # mínimo raw count en alguna muestra
                     min.mem = 0.5)      # mínimo CPM
dge  <- dge[keep, , keep.lib.sizes = FALSE]
cat("Después de filtrar:", nrow(dge), "variantes quedan\n")
```

```{r}
# Chunk I ─── Normalizar librerías (TMM)
dge <- calcNormFactors(dge, method = "TMM")
# Chequeo de factores
dge$samples$norm.factors
```

```{r}
# Chunk J ─── Diseño y estimación de dispersiones (robusto)
design <- model.matrix(~ 0 + batch, data = dge$samples)
colnames(design) <- levels(dge$samples$batch)

dge <- estimateDisp(dge,
                    design,
                    robust = TRUE)   # robust contra outliers
plotBCV(dge)                # inspección visual
```




```{r}
library(tibble)

df_long <- as.data.frame(dge$counts) %>%
  rownames_to_column("featureID") %>%  
  pivot_longer(-featureID,
               names_to  = "sample",
               values_to = "count") %>%
  # 1.2 Pego metadata de muestras
  left_join(dge$samples, by = c("sample"="sample")) %>%
  # 1.3 Extraigo posición y el cambio de featureID
  separate(featureID,
           into = c("miRNA","pos_mut"),
           sep   = "_(?=[0-9]+_[ACGT]{2,2}$)",  # lookahead para la última parte
           remove = FALSE) %>%
  separate(pos_mut,
           into = c("position","change"),
           sep = "_",
           convert = TRUE)
```




```{r heatmap_processing}
library(dplyr)
library(tidyr)

# 1) Sumar los reads por variant×position
df_tot <- df_long %>%
  group_by(featureID, position) %>%
  summarise(total = sum(count), .groups="drop") %>%
  mutate(position = as.integer(position))

# 2) Elegir Top100 y Bottom100 según el total global
variant_totals <- df_tot %>%
  group_by(featureID) %>%
  summarise(overall = sum(total), .groups="drop") %>%
  arrange(desc(overall))

sel_top <- variant_totals$featureID[1:100]
sel_bot <- tail(variant_totals$featureID, 100)

# 3) Preparar df_main, df_top, df_bot con factores ordenados
feature_order <- variant_totals$featureID

df_main <- df_tot %>%
  mutate(featureID = factor(featureID, levels = feature_order))

df_top <- df_main %>%
  filter(featureID %in% sel_top) %>%
  mutate(featureID = factor(featureID, levels = sel_top))

df_bot <- df_main %>%
  filter(featureID %in% sel_bot) %>%
  mutate(featureID = factor(featureID, levels = sel_bot))

# 4) Calcular máximo para la escala de color (ej. max de total)
max_tot <- ceiling(max(df_main$total))

# 5) Definir la escala white→red con límites adaptados
red_scale <- scale_fill_gradient(
  low      = "white",
  high     = "#CD0000",
  limits   = c(0, max_tot),
  breaks   = seq(0, max_tot, length.out = 6),
  labels   = scales::comma(seq(0, max_tot, length.out = 6)),
  name     = "Reads"
)
```

```{r}
# 1) ¿Cómo viene tu df_long?
#    Mira las primeras filas y el rango de posiciones y counts
head(df_long)
summary(df_long$count)
table(df_long$position)

# 2) Verifica df_tot
head(df_tot)
summary(df_tot$total)
table(df_tot$position)

# 3) Revisa variant_totals
head(variant_totals)
tail(variant_totals)
summary(variant_totals$overall)

# 4) Confirma los subconjuntos Top/Bottom
length(sel_top); head(sel_top)
length(sel_bot); head(sel_bot)
```


```{r}
library(ggplot2)
library(patchwork)
library(RColorBrewer)

red_scale <- scale_fill_distiller(
  palette   = "YlOrRd",   # de amarillo (bajo) a rojo oscuro (alto)
  direction = 1,
  limits    = c(0, max(df_main$total, na.rm = TRUE)),
  name      = "Reads",
  trans     = "sqrt",     # idem, opcional
  na.value  = "grey90"
)
# — Main heatmap (todas las variantes) —
p_main <- ggplot(df_main, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(y = paste0("SNVs (n = ", length(levels(df_main$featureID)), ")"),
       x = NULL) +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid   = element_blank(),
    plot.margin  = margin(5,5,5,5)
  )

# — Inset Top100 —
p_top <- ggplot(df_top, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(title = "Top 100") +
  theme_minimal(base_size = 10) +
  theme(
    axis.text   = element_blank(),
    axis.ticks  = element_blank(),
    panel.grid  = element_blank(),
    plot.title  = element_text(color = "#CD0000", size = 12, face = "bold"),
    plot.margin = margin(5,5,5,5)
  )

# — Inset Bottom100 —
p_bot <- ggplot(df_bot, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(title = "Bottom") +
  theme_minimal(base_size = 10) +
  theme(
    axis.text   = element_blank(),
    axis.ticks  = element_blank(),
    panel.grid  = element_blank(),
    plot.title  = element_text(color = "grey50", size = 12, face = "bold"),
    plot.margin = margin(5,5,5,5)
  )

# — Ensamble con patchwork y titulación —
(p_main | (p_top / p_bot)) +
  plot_layout(widths = c(3,1), guides = "collect") +
  plot_annotation(
    title    = expression(underline("miRNA_seq")),
    subtitle = "1    Position    22"
  ) &
  theme(
    plot.title      = element_text(size=16, face="bold", hjust=0.5),
    plot.subtitle   = element_text(size=14, hjust=0.5),
    legend.position = "right"
  )

nrow(df_main)
```

```{r}
# 1. log-CPM
logCPM <- cpm(dge, log=TRUE, prior.count=1)

# 2. (Opcional) filtrar genes muy poco variables
# var_genes <- rowVars(logCPM)
# topN     <- 500
# keep     <- order(var_genes, decreasing=TRUE)[1:topN]
# mat_sub  <- logCPM[keep, ]

# SI QUIERES _TODAS_ las filas, comenta lo anterior y usa:
mat_sub <- logCPM

# 3. PCA
pca <- prcomp(t(mat_sub), center=TRUE, scale.=FALSE)

# 4. Construir el tibble de scores
pca_df <- as.data.frame(pca$x) %>%            # convierte la matriz a data.frame
  rownames_to_column(var="sample") %>%        # mueve los rownames a una columna
  select(sample, PC1, PC2) %>%                # me quedo solo con PC1 y PC2
  left_join(sample_table, by="sample")        # une tus metadatos (batch, rep)

# 5. % de varianza
pct <- round(100 * (pca$sdev^2 / sum(pca$sdev^2)), 1)

# 6. Plot
ggplot(pca_df, aes(x=PC1, y=PC2, color=batch, shape=rep)) +
  geom_point(size=3) +
  labs(
    x = paste0("PC1 (", pct[1], "%)"),
    y = paste0("PC2 (", pct[2], "%)"),
    color = "Batch",
    shape = "Replicate"
  ) +
  theme_minimal(base_size=12) +
  theme(
    legend.position = "right",
    panel.grid.minor = element_blank()
  )
```

```{r}


```