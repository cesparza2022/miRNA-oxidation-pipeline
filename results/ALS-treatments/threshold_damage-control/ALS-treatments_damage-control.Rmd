---
title: "mi-8oG-ALS-treatments_damage-controls"
author: "César Esparza"
date: "2025-04-23"
output: html_document
---

```{r}
install.packages("stringr")
install.packages("janitor")
install.packages("limma")


if (!requireNamespace("DESeq2", quietly=TRUE)) {
  BiocManager::install("DESeq2")
}


if (!requireNamespace("edgeR", quietly=TRUE)) {
  BiocManager::install("edgeR")
}

```

```{r}
library(rlang)
library(stringr)
library(tidyverse)
library(janitor)
library(DESeq2)
library(limma)
library(edgeR)
```



```{r}

df_raw <- read_tsv("/Users/cesaresparza/New_Desktop/UCSD/8OG/results/ALS-treatments/threshold_damage-control/miRNA_count.Q35.txt") %>%
  clean_names().

colnames(df_raw)
```
```{r}

df_snv <- df_raw %>%
  filter(pos_mut != "PM")


n_raw <- nrow(df_raw)
n_snv <- nrow(df_snv)
message("Filas totales: ", n_raw, 
        " → Filas sin PM: ", n_snv,
        " (eliminadas: ", n_raw - n_snv, ")")
```


```{r}
split_mutations <- function(df, mut_col = "pos_mut") {
  col_sym <- sym(mut_col)
  df %>% 
    separate_rows(!!col_sym, sep = ",") %>% 
    mutate(!!col_sym := str_trim(!!col_sym))
}

df_snv_split <- split_mutations(df_snv, "pos_mut")


df_snv_split %>% 
  filter(str_detect(pos_mut, ",")) %>% 
  nrow()   # debe dar 0


```


```{r}
collapse_mutations <- function(df, mut_col = "pos_mut") {
  # 4.1. Identificar columnas de conteo puro (excluyendo totales PM+1MM+2MM)
  count_cols <- df %>% 
    select(starts_with("trimmed_")) %>% 
    select(-ends_with("_pm_1mm_2mm")) %>% 
    names()
  
  # 4.2. Agrupar por miRNA + mutación (posición:mut) y sumar los reads
  df %>%
    group_by(mi_rna_name, !!sym(mut_col)) %>%
    summarise(across(all_of(count_cols), sum), .groups = "drop") 
}

# Aplicar al df_snv_split (resultado de split_mutations)
df_collapsed <- collapse_mutations(df_snv_split, "pos_mut")


```


```{r}
df_collapsed
```
```{r}

count_cols <- df_collapsed %>%
  select(starts_with("trimmed_")) %>%
  select(-ends_with("_pm_1mm_2mm")) %>%
  names()
```

```{r}

df_DE <- df_collapsed %>%
  mutate(
    pos_mut   = str_replace_all(pos_mut, ":", "_"),
    featureID = paste(mi_rna_name, pos_mut, sep = "_")
  ) %>%
  select(featureID, all_of(count_cols)) %>%
  column_to_rownames("featureID")

count_mat <- as.matrix(df_DE)


# 4) Forzar integer (requisito de edgeR)
mode(count_mat) <- "integer"


stopifnot(exists("count_mat"))
stopifnot(!any(is.na(count_mat)))

cat("Dimensions of count_mat:", dim(count_mat), 
    "(rows = variants, cols = samples)\n")
```


```{r}
library(tibble)
library(stringr)

clean <- colnames(count_mat) %>%
  str_to_lower() %>%
  str_replace_all("-", "_")


count_cols <- setdiff(colnames(count_mat), c("mirna_name", "pos_mut"))


sample_table <- tibble(sample = count_cols) %>%
  mutate(
    # quito el prefijo
    core      = str_remove(sample, "^trimmed_ngn2_"),
    # treatment = todo antes de "_rep" o "_srr"
    treatment = str_remove(core, "(?:_rep[0-9]+_[0-9]+)?(?:_srr[0-9]+)$"),
    # batch = lo que venga tras "rep"
    batch     = str_extract(core, "(?<=_rep)[0-9]"),
    # marca controles
    is_control= (treatment == "nc_dmso")
  ) %>%
  select(-core)

print(setdiff(count_cols, sample_table$sample))  # debe ser character(0)
print(setdiff(sample_table$sample, count_cols)) 

# quick check
print(sample_table)
```

```{r}


variant_sums <- rowSums(count_mat)


cutoff <- quantile(variant_sums, probs = 0.99)


n_out <- sum(variant_sums > cutoff)
cat("Eliminando", n_out, "variantes (", 
    round(100 * n_out/length(variant_sums),1), 
    "%) con total >", round(cutoff,1), "lecturas\n")


keep_vars  <- names(variant_sums)[variant_sums <= cutoff]
count_mat   <- count_mat[keep_vars, , drop = FALSE]
```




```{r}
dge <- DGEList(counts = count_mat, samples = sample_table)
```

```{r}
dge
```


```{r}
# 1) Exploración inicial
plotMDS(dge, labels = dge$samples$treatment)     # MDS/PCA para ver clustering
```

```{r}
# 2) Filtrado de bajo conteo
keep <- filterByExpr(dge, group = dge$samples$treatment)
dge  <- dge[keep, , keep.lib.sizes=FALSE]
```


```{r}
# 3) Normalización
dge  <- calcNormFactors(dge)                     # TMM
```

```{r}

design <- model.matrix(~ 0 + treatment, data = dge$samples)

```


```{r}
# 5) Estimar dispersión
dge     <- estimateDisp(dge, design)

```

```{r}
library(Matrix)
library(dplyr)
library(tidyr)
library(stringr)

# 1) convierte tu matriz a sparse
sparse_mat <- Matrix(count_mat, sparse = TRUE)

# 2) summary() te da un data.frame i,j,x con filas no–ceros
s <- summary(sparse_mat)
snv_long <- tibble(
  feature = rownames(count_mat)[s$i],
  sample  = colnames(count_mat)[s$j],
  n_mut   = s$x
) %>%
  # 3) separa feature en miRNA/pos/mut
  separate(feature, into = c("miRNA","pos","mut"), sep = "_", convert = TRUE) %>%
  mutate(
    ref      = str_sub(mut,1,1),
    alt      = str_sub(mut,2,2),
    mut_type = paste0(ref,">",alt)
  ) %>%
  # 4) añade metadata de sample_table
  left_join(sample_table, by = "sample")

# Quick check
snv_long %>% slice_head(n=10)
```


```{r}

total_snvs <- colSums(dge$counts)
gt_idx     <- grepl("G>T", rownames(dge$counts))
gt_snvs    <- colSums(dge$counts[gt_idx, ])
ga_idx     <- grepl("G>A", rownames(dge$counts))
ga_snvs    <- colSums(dge$counts[ga_idx, ])

```

```{r}
library(dplyr)
library(ggplot2)
library(patchwork)



snv_summary <- snv_long %>%
  # total SNVs y G→T por muestra
  group_by(sample, treatment, batch, is_control) %>%
  summarise(
    total = sum(n_mut),
    gt    = sum(if_else(mut_type=="G>T", n_mut, 0L)),
    .groups="drop"
  )


ctrl_stats <- snv_summary %>%
  filter(is_control) %>%
  group_by(batch) %>%
  summarise(
    mean_total = mean(total), sd_total = sd(total),
    mean_gt    = mean(gt),    sd_gt    = sd(gt),
    .groups="drop"
  )


treat_total <- snv_summary %>%
  filter(!is_control) %>%
  group_by(treatment) %>%
  summarise(mean_total = mean(total), .groups="drop") %>%
  arrange(mean_total) %>%
  mutate(treatment = factor(treatment, levels = treatment))

treat_gt <- snv_summary %>%
  filter(!is_control) %>%
  group_by(treatment) %>%
  summarise(mean_gt = mean(gt), .groups="drop") %>%
  arrange(mean_gt) %>%
  mutate(treatment = factor(treatment, levels = treatment))

# 4) Gráfico 1: Total SNVs
p_total <- ggplot(treat_total, aes(treatment, mean_total)) +
  # líneas de control
  geom_hline(data=ctrl_stats,
             aes(yintercept=mean_total, linetype=factor(batch)),
             color="grey50") +
  # banda (± SD)
  geom_rect(data=ctrl_stats,
            aes(xmin=-Inf, xmax=Inf,
                ymin=mean_total - sd_total,
                ymax=mean_total + sd_total),
            fill="grey80", inherit.aes=FALSE) +
  geom_point(color="steelblue", size=3) +
  coord_flip() +
  labs(
    title="Total SNV burden",
    subtitle="Líneas = control mean por batch (–+ SD)",
    x=NULL, y="Mean total SNVs"
  ) +
  theme_minimal() +
  theme(legend.position="bottom",
        plot.title=element_text(face="bold", hjust=0.5),
        plot.subtitle=element_text(hjust=0.5))

# 5) Gráfico 2: Oxidative (G→T)
p_gt <- ggplot(treat_gt, aes(treatment, mean_gt)) +
  geom_hline(data=ctrl_stats,
             aes(yintercept=mean_gt, linetype=factor(batch)),
             color="grey50") +
  geom_rect(data=ctrl_stats,
            aes(xmin=-Inf, xmax=Inf,
                ymin=mean_gt - sd_gt,
                ymax=mean_gt + sd_gt),
            fill="grey90", inherit.aes=FALSE) +
  geom_point(color="firebrick", size=3) +
  coord_flip() +
  labs(
    title="Oxidative damage (G→T)",
    subtitle="Líneas = control mean por batch (–+ SD)",
    x=NULL, y="Mean G→T"
  ) +
  theme_minimal() +
  theme(legend.position="bottom",
        plot.title=element_text(face="bold", hjust=0.5),
        plot.subtitle=element_text(hjust=0.5))

# 6) Combinar con patchwork
p_total + p_gt + 
  plot_layout(ncol=2) & 
  theme(strip.text = element_blank())
```
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)


df2 <- snv_long %>%
  group_by(sample, treatment, is_control) %>%
  summarise(
    total_SNVS = sum(n_mut),
    total_GT   = sum(if_else(mut_type=="G>T", n_mut, 0L)),
    .groups="drop"
  ) %>%
  pivot_longer(
    cols = c(total_SNVS, total_GT),
    names_to  = "metric",
    values_to = "count"
  ) %>%
  mutate(
    metric = recode(metric,
                    total_SNVS = "Total SNVs",
                    total_GT   = "Oxidative (G→T)")
  )


ggplot(df2, aes(x = treatment, y = count)) +
  # violín sólo para controles
  geom_violin(data = filter(df2, is_control),
              fill = "grey80", color = NA, alpha = 0.8) +
  # puntos pequeños para controles
  geom_jitter(data = filter(df2, is_control),
              aes(color = "Control"), width = 0.15, size = 1.5, alpha = 0.6) +
  # puntos grandes para tratamientos
  geom_point(data = filter(df2, !is_control),
             aes(color = "Treatment"), size = 3) +
  facet_wrap(~ metric, scales = "free_y", nrow = 1) +
  scale_color_manual(name = "",
                     values = c(Control = "black",
                                Treatment = "tomato")) +
  coord_flip() +
  labs(x = "Tratamiento",
       y = "Count",
       title = "treatments vs control distribution") +
  theme_minimal() +
  theme(
    legend.position = "top",
    axis.text.y      = element_text(size = 9),
    strip.text       = element_text(face = "bold")
  )
```
```{r}
library(forcats)

# 1) Calcular total y G→T por muestra
df_z <- snv_long %>%
  group_by(sample, treatment) %>%
  summarise(
    total = sum(n_mut),
    gt    = sum(if_else(mut_type=="G>T", n_mut, 0L)),
    .groups="drop"
  ) %>%
  pivot_longer(
    cols      = c(total, gt),
    names_to  = "metric",
    values_to = "count"
  ) %>%
  # 2) Para cada métrica, obtener media/SD de controles
  group_by(metric) %>%
  mutate(
    ctrl_mean = mean(count[treatment=="nc_dmso"]),
    ctrl_sd   = sd(count[treatment=="nc_dmso"]),
    zscore    = (count - ctrl_mean) / ctrl_sd
  ) %>%
  ungroup() %>%
  filter(treatment != "nc_dmso") %>%       # sólo tratamientos
  mutate(
    metric = recode(metric,
                    total = "Total SNVs",
                    gt    = "Oxidative (G→T)")
  )

# 3) Barplot de z‐scores
ggplot(df_z, aes(x = fct_reorder(treatment, zscore), y = zscore)) +
  geom_col(fill = "tomato") +
  facet_wrap(~ metric, scales = "free_y", nrow = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  coord_flip() +
  labs(
    x     = "Treatment",
    y     = "Z-score vs control",
    title = "standarized divergence between treatment and controls "
  ) +
  theme_minimal() +
  theme(
    plot.title  = element_text(hjust = 0.5, face = "bold"),
    axis.text.y = element_text(size = 9)
  )
```



```{r}
library(dplyr)
library(tidyr)
library(ggplot2)


miRNA_summary <- snv_long %>%
  group_by(miRNA) %>%
  summarise(
    totalSNV = sum(n_mut),
    OxidGT   = sum(if_else(mut_type=="G>T", n_mut, 0L)),
    AlkGA    = sum(if_else(mut_type=="G>A", n_mut, 0L)),
    .groups = "drop"
  )

top10_miRNAs <- miRNA_summary %>%
  slice_max(totalSNV, n = 10) %>%
  pull(miRNA)

# 2) Filtra y pasa a formato largo
grouped_df <- miRNA_summary %>%
  filter(miRNA %in% top10_miRNAs) %>%
  pivot_longer(
    cols      = c(totalSNV, OxidGT, AlkGA),
    names_to  = "metric",
    values_to = "count"
  ) %>%
  mutate(
    metric = recode(metric,
                    totalSNV = "Total SNVs",
                    OxidGT   = "G→T",
                    AlkGA    = "G→A"),
    miRNA  = factor(miRNA, levels = top10_miRNAs[order(miRNA_summary$totalSNV[match(top10_miRNAs, miRNA_summary$miRNA)], decreasing = TRUE)])
  )

# 3) Gráfico de barras agrupadas
ggplot(grouped_df, aes(x = miRNA, y = count, fill = metric)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  scale_fill_manual(values = c("Total SNVs" = "grey40",
                               "G→T"        = "firebrick",
                               "G→A"        = "darkgreen")) +
  coord_flip() +
  labs(
    title = "Top-10 miRNAs: general damage, oxidation y al",
    x     = "miRNA",
    y     = "Count",
    fill  = "Tipo de mutación"
  ) +
  theme_minimal() +
  theme(
    plot.title   = element_text(face = "bold", hjust = 0.5),
    axis.text.y  = element_text(size = 10)
  )
```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# 1) Top-10 miRNAs por G→T
top10_oxid <- snv_long %>%
  filter(mut_type == "G>T") %>%
  group_by(miRNA) %>%
  summarise(total_gt = sum(n_mut), .groups = "drop") %>%
  slice_max(total_gt, n = 10) %>%
  pull(miRNA)

# 2) Treatments: suma G→T
treat_heat <- snv_long %>%
  filter(!is_control, miRNA %in% top10_oxid, mut_type == "G>T") %>%
  group_by(miRNA, treatment) %>%
  summarise(count = sum(n_mut), .groups = "drop")

# 3) Controls: suma G→T por batch
control_heat <- snv_long %>%
  filter(is_control, batch != "3",      # <— descartamos controles de batch 3
         miRNA %in% top10_oxid,
         mut_type == "G>T") %>%
  group_by(miRNA, batch) %>%
  summarise(count = sum(n_mut), .groups = "drop") %>%
  mutate(treatment = paste0("ctrl_batch"))


# 4) Combinar y rellenar combinaciones faltantes
heat_df2 <- bind_rows(
  treat_heat,
  control_heat %>% select(miRNA, treatment, count)
) %>%
  complete(miRNA, treatment, fill = list(count = 0))

# 5) Definir los niveles para que controles aparezcan primero
ctrl_lvls  <- sort(unique(control_heat$treatment))
treat_lvls <- sort(unique(treat_heat$treatment))
all_lvls   <- c(ctrl_lvls, treat_lvls)

heat_df2 <- heat_df2 %>%
  mutate(
    miRNA     = factor(miRNA, levels = rev(top10_oxid)),
    treatment = factor(treatment, levels = all_lvls)
  )

# 6) Plot
ggplot(heat_df2, aes(x = treatment, y = miRNA, fill = count)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(option = "magma", name = "G→T\ncount") +
  labs(
    title = "Oxidative hotspots (G→T) en top-10 miRNAs",
    x     = "Treatments",
    y     = "miRNA"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    axis.text.y = element_text(size = 9),
    plot.title  = element_text(face = "bold", hjust = 0.5)
  )
```



```{r}
library(dplyr)
library(ggplot2)
library(patchwork)

# 1) Resumen por miRNA: total SNVs, G→T y G→A
miRNA_summary <- snv_long %>%
  group_by(miRNA) %>%
  summarise(
    total = sum(n_mut),
    GT    = sum(if_else(mut_type=="G>T", n_mut, 0L)),
    GA    = sum(if_else(mut_type=="G>A", n_mut, 0L)),
    .groups = "drop"
  )

# 2) Extraer top-10 en cada categoría
top_total <- miRNA_summary %>% slice_max(total, n = 10)
top_GT    <- miRNA_summary %>% slice_max(GT,    n = 10)
top_GA    <- miRNA_summary %>% slice_max(GA,    n = 10)

# 3) Graficar barras horizontales
p_total <- ggplot(top_total, aes(x = reorder(miRNA, total), y = total)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
       x = NULL, y = "SNV total") +
  theme_minimal()

p_GT <- ggplot(top_GT, aes(x = reorder(miRNA, GT), y = GT)) +
  geom_col(fill = "firebrick") +
  coord_flip() +
  labs(
       x = NULL, y = "G→T count") +
  theme_minimal()

p_GA <- ggplot(top_GA, aes(x = reorder(miRNA, GA), y = GA)) +
  geom_col(fill = "darkgreen") +
  coord_flip() +
  labs(
       x = NULL, y = "G→A count") +
  theme_minimal()

# 4) Combinar gráficos en una sola figura
(p_total | p_GT | p_GA) + 
  plot_layout(ncol = 3, widths = c(1,1,1))
```


```{r}


# 1) Calcular G→T por posición para cada muestra, excluyendo controles batch 3
pos_df <- snv_long %>%
  filter(mut_type == "G>T") %>%
  filter(!(is_control & batch == "3")) %>%     # <— descartamos controles de batch 3
  group_by(sample, treatment, batch, is_control, pos) %>%
  summarise(count = sum(n_mut), .groups="drop")

# 2) Promedio de controles por batch (ahora solo batch 1 y 2)
control_pos <- pos_df %>%
  filter(is_control) %>%
  group_by(batch, pos) %>%
  summarise(count = mean(count), .groups="drop") %>%
  mutate(treatment = paste0("ctrl_batch", batch))

# 3) Media de tratamientos
treat_pos <- pos_df %>%
  filter(!is_control) %>%
  group_by(treatment, pos) %>%
  summarise(count = mean(count), .groups="drop")

# resto sin cambios...
all_pos <- bind_rows(
  control_pos %>% select(treatment, pos, count),
  treat_pos
)

top_treats <- treat_pos %>%
  group_by(treatment) %>%
  summarise(total_gt = sum(count), .groups="drop") %>%
  slice_max(total_gt, n = 6) %>%
  pull(treatment)

keep_levels <- c(
  paste0("ctrl_batch", sort(unique(control_pos$batch))),
  top_treats
)

all_pos2 <- all_pos %>%
  filter(treatment %in% keep_levels) %>%
  mutate(treatment = factor(treatment, levels = keep_levels))

# 7) Plot faceteado
ggplot(all_pos2, aes(x = pos, y = count)) +
  geom_line(color = "firebrick", size = 1) +
  geom_point(color = "firebrick", size = 2) +
  facet_wrap(~ treatment, scales = "free_y", ncol = 4) +
  scale_x_continuous(breaks = 1:22) +
  labs(
    title = "Distribución posicional de daño oxidativo (G→T)\nControles por batch vs tratamientos top",
    x     = "Posición en el miRNA",
    y     = "Avg G→T count"
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    axis.text.x     = element_text(size = 7),
    plot.title      = element_text(hjust = 0.5, face = "bold")
  )
```

```{r}

library(dplyr)
library(ggplot2)
library(tidyr)

# 1) Top-10 miRNAs por G→T (ya lo tenías)
top10_oxid <- snv_long %>%
  filter(mut_type=="G>T") %>%
  group_by(miRNA) %>%
  summarise(total_gt = sum(n_mut), .groups="drop") %>%
  slice_max(total_gt, n = 10) %>%
  pull(miRNA)

# 2) Calcular G→T *solo* para esos top-10, por posición y tratamiento
pos_df <- snv_long %>%
  filter(mut_type=="G>T", miRNA %in% top10_oxid) %>%
  filter(!(is_control & batch == "3")) %>%     # <— descartamos controles de batch 3
  group_by(treatment, pos, is_control, batch) %>%
  summarise(count = sum(n_mut), .groups="drop")

# 3) Controles: media de las réplicas por batch
ctrl_pos <- pos_df %>%
  filter(is_control) %>%
  group_by(batch, pos) %>%
  summarise(count = mean(count), .groups="drop") %>%
  mutate(treatment = paste0("ctrl_batch", batch))

# 4) Tratamientos: como antes (cada uno es una réplica)
treat_pos <- pos_df %>%
  filter(!is_control) %>%
  group_by(treatment, pos) %>%
  summarise(count = mean(count), .groups="drop")

# 5) Combinar y asegurarnos de tener todos los pares
plot_df <- bind_rows(
  ctrl_pos %>% select(treatment, pos, count),
  treat_pos
) %>%
  complete(treatment, pos = 1:22, fill = list(count = 0))

# 6) Ordenar niveles (controles primero)
levels_treat <- c(sort(unique(ctrl_pos$treatment)), sort(unique(treat_pos$treatment)))
plot_df$treatment <- factor(plot_df$treatment, levels = levels_treat)

# 7) Dibujar facetas
ggplot(plot_df, aes(x = pos, y = count)) +
  geom_line(color = "firebrick", size = 1) +
  geom_point(color = "firebrick", size = 2) +
  facet_wrap(~ treatment, ncol = 4, scales = "free_y") +
  scale_x_continuous(breaks = 1:22, labels = as.character(1:22)) +
  labs(
    title = "Bias posicional de G→T en top-10 miRNAs vs controles por batch",
    x     = "Posición en el miRNA",
    y     = "Avg G→T count"
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    axis.text.x     = element_text(size = 7),
    plot.title      = element_text(hjust = 0.5, face = "bold")
  )
```

```{r}
ggplot(plot_df, aes(x = pos, y = count)) +
  geom_line(color = "firebrick", size = 1) +
  geom_point(color = "firebrick", size = 2) +
  facet_wrap(~ treatment, ncol = 4, scales = "fixed") +  # <-- escala fija
  scale_x_continuous(breaks = 1:22) +
  labs(
    title = "Bias posicional de G→T en top-10 miRNAs\n(escala Y fija para todas las facetas)",
    x     = "Posición en el miRNA",
    y     = "Avg G→T count"
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    axis.text.x     = element_text(size = 7),
    plot.title      = element_text(hjust = 0.5, face = "bold")
  )
```

```{r}
library(dplyr)
library(tidyr)

# 1) Sumar los reads por variant×position
df_tot <- df_long %>%
  group_by(featureID, position) %>%
  summarise(total = sum(count), .groups="drop") %>%
  mutate(position = as.integer(position))

# 2) Elegir Top100 y Bottom100 según el total global
variant_totals <- df_tot %>%
  group_by(featureID) %>%
  summarise(overall = sum(total), .groups="drop") %>%
  arrange(desc(overall))

sel_top <- variant_totals$featureID[1:100]
sel_bot <- tail(variant_totals$featureID, 100)

# 3) Preparar df_main, df_top, df_bot con factores ordenados
feature_order <- variant_totals$featureID

df_main <- df_tot %>%
  mutate(featureID = factor(featureID, levels = feature_order))

df_top <- df_main %>%
  filter(featureID %in% sel_top) %>%
  mutate(featureID = factor(featureID, levels = sel_top))

df_bot <- df_main %>%
  filter(featureID %in% sel_bot) %>%
  mutate(featureID = factor(featureID, levels = sel_bot))

# 4) Calcular máximo para la escala de color (ej. max de total)
max_tot <- ceiling(max(df_main$total))

# 5) Definir la escala white→red con límites adaptados
red_scale <- scale_fill_gradient(
  low      = "white",
  high     = "#CD0000",
  limits   = c(0, max_tot),
  breaks   = seq(0, max_tot, length.out = 6),
  labels   = scales::comma(seq(0, max_tot, length.out = 6)),
  name     = "Reads"
)
```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)

# 1) Filtrar solo SNVs en seed (pos 2–8) y batch 2 (si ya lo fijaste)
seed_snvs <- snv_long %>%
  filter(pos >= 2, pos <= 8)

# 2) Calcular total de SNVs en seed por miRNA, rankear y quedarnos con top N
topN <- 200
miRNA_rank <- seed_snvs %>%
  group_by(miRNA) %>%
  summarise(seed_count = sum(n_mut), .groups="drop") %>%
  arrange(desc(seed_count)) %>%
  slice(1:topN) %>%
  pull(miRNA)

seed_top <- seed_snvs %>%
  filter(miRNA %in% miRNA_rank) %>%
  # forzar el mismo orden que en miRNA_rank
  mutate(miRNA = factor(miRNA, levels=miRNA_rank))

# 3) Expandir cada SNV según su conteo para ponderar bien las fracciones
#    (si tienes muchas rep, este paso puede ser lento; sino, puedes usar pesos)
seed_expanded <- seed_top %>% uncount(n_mut)

# 4) Para cada k = 1..topN, calcular fracción acumulada de cada nuc/ref
frac_ref <- map_dfr(1:topN, function(k){
  sel_mi <- levels(seed_expanded$miRNA)[1:k]
  dfk <- seed_expanded %>% filter(miRNA %in% sel_mi)
  total <- nrow(dfk)
  dfk %>% count(ref) %>%
    complete(ref = c("A","T","G","C"), fill=list(n=0)) %>%
    mutate(rank = k, frac = n/total)
})

# 5) Panel izq: fraction vs rank by ref base
p1 <- ggplot(frac_ref, aes(x=rank, y=frac, color=ref)) +
  geom_line(size=0.8) +
  scale_color_manual(values=c(A="dodgerblue", T="firebrick", 
                              G="orange", C="purple")) +
  labs(title="SNVs in seed (by reference base)",
       x="Top k miRNAs (ranked by seed SNVs)",
       y="Fraction of SNVs",
       color="Ref base") +
  theme_minimal() +
  theme(legend.position="top")

# 6) Ahora para mut_type empezamos igual
mut_expanded <- seed_top %>% uncount(n_mut)

frac_mut <- map_dfr(1:topN, function(k){
  sel_mi <- levels(mut_expanded$miRNA)[1:k]
  dfk <- mut_expanded %>% filter(miRNA %in% sel_mi)
  total <- nrow(dfk)
  dfk %>% count(mut_type) %>%
    complete(mut_type = c("G>T","G>C","G>A"), fill=list(n=0)) %>%
    mutate(rank = k, frac = n/total)
})

# 7) Panel der: fraction vs rank by mutation
p2 <- ggplot(frac_mut, aes(x=rank, y=frac, color=mut_type)) +
  geom_line(size=0.8) +
  scale_color_manual(values=c("G>T"="firebrick","G>C"="purple","G>A"="dodgerblue")) +
  labs(title="SNVs in seed (by mutation type)",
       x="Top k miRNAs (ranked by seed SNVs)",
       y="Fraction of SNVs",
       color="Mutation") +
  theme_minimal() +
  theme(legend.position="top")

# 8) Combinar
p1 + p2 + plot_layout(ncol=2)
```


```{r}
library(ggplot2)
library(patchwork)
library(RColorBrewer)

red_scale <- scale_fill_distiller(
  palette   = "YlOrRd",   # de amarillo (bajo) a rojo oscuro (alto)
  direction = 1,
  limits    = c(0, max(df_main$total, na.rm = TRUE)),
  name      = "Reads",
  trans     = "sqrt",     # idem, opcional
  na.value  = "grey90"
)
# — Main heatmap (todas las variantes) —
p_main <- ggplot(df_main, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(y = paste0("SNVs (n = ", length(levels(df_main$featureID)), ")"),
       x = NULL) +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid   = element_blank(),
    plot.margin  = margin(5,5,5,5)
  )

# — Inset Top100 —
p_top <- ggplot(df_top, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(title = "Top 100") +
  theme_minimal(base_size = 10) +
  theme(
    axis.text   = element_blank(),
    axis.ticks  = element_blank(),
    panel.grid  = element_blank(),
    plot.title  = element_text(color = "#CD0000", size = 12, face = "bold"),
    plot.margin = margin(5,5,5,5)
  )

# — Inset Bottom100 —
p_bot <- ggplot(df_bot, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(title = "Bottom") +
  theme_minimal(base_size = 10) +
  theme(
    axis.text   = element_blank(),
    axis.ticks  = element_blank(),
    panel.grid  = element_blank(),
    plot.title  = element_text(color = "grey50", size = 12, face = "bold"),
    plot.margin = margin(5,5,5,5)
  )

# — Ensamble con patchwork y titulación —
(p_main | (p_top / p_bot)) +
  plot_layout(widths = c(3,1), guides = "collect") +
  plot_annotation(
    title    = expression(underline("miRNA_seq")),
    subtitle = "1    Position    22"
  ) &
  theme(
    plot.title      = element_text(size=16, face="bold", hjust=0.5),
    plot.subtitle   = element_text(size=14, hjust=0.5),
    legend.position = "right"
  )

nrow(df_main)
```

```{r}
library(dplyr)
library(ggplot2)

df_corr <- snv_long %>%
  group_by(sample, treatment) %>%
  summarise(
    totalSNV = sum(n_mut),
    GT       = sum(if_else(mut_type=="G>T", n_mut, 0L)),
    .groups="drop"
  )

ggplot(df_corr, aes(x = totalSNV, y = GT, color = treatment)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_smooth(method="lm", se=FALSE, color="black", linetype="dashed") +
  labs(
    title = "Total SNVs vs. Oxidative (G→T)",
    x     = "Total SNVs",
    y     = "Total G→T"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust=0.5))
```



```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggfortify)

# 1) Prepara matriz wide: muestras × tipo de mutación
mat <- snv_long %>%
  group_by(sample, mut_type) %>%
  summarise(count = sum(n_mut), .groups="drop") %>%
  pivot_wider(names_from = mut_type, values_from = count, values_fill = 0) %>%
  column_to_rownames("sample")

# 2) PCA
pca_res <- prcomp(mat, scale.=TRUE)

# 3) Autoplot coloreando por treatment
meta <- unique(snv_long[, c("sample","treatment")])
autoplot(pca_res, data = meta, colour = 'treatment', size=3) +
  labs(title="PCA de perfiles de mutación") +
  theme_minimal() +
  theme(plot.title = element_text(hjust=0.5))
```

```{r}
library(dplyr)
library(ggplot2)

# Asumiendo que plot_df ya existe y tiene columns: treatment, pos, count
plot_df_initial <- plot_df %>%
  filter(pos <= 18)   # <-- aquí definimos hasta la posición 18
  filter(!(is_control & batch == "3")) %>%     # <— descartamos controles de batch 3
    
ggplot(plot_df_initial, aes(x = pos, y = count)) +
  geom_linerange(aes(ymin = 0, ymax = count),
                 color = "firebrick", alpha = 0.4) +
  geom_line(size = 0.4, color = "firebrick") +
  geom_point(size = 1, color = "firebrick") +
  facet_wrap(~ treatment, ncol = 4, scales = "fixed") +
  scale_x_continuous(breaks = 1:18, labels = as.character(1:18)) +
  labs(
    title = "Sesgo posicional de G→T (posiciones 1–18)",
    x     = "Posición en el miRNA",
    y     = "Avg G→T count"
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    axis.text.x     = element_text(size = 7),
    plot.title      = element_text(hjust = 0.5, face = "bold")
  )
```


```{r}
library(dplyr)
library(ggplot2)

# Usamos la misma data de antes: plot_df con treatment, pos, count
# y levels ya definidos.

ggplot(plot_df, aes(x = pos, y = count)) +
  # Spikes desde 0 hasta count
  geom_linerange(aes(ymin = 0, ymax = count),
                 color = "firebrick", alpha = 0.4) +
  # Línea delgada uniendo los puntos
  geom_line(size = 0.4, color = "firebrick") +
  # Puntos pequeñitos en cada posición
  geom_point(size = 1, color = "firebrick") +
  facet_wrap(~ treatment, ncol = 4, scales = "fixed") +
  scale_x_continuous(breaks = 1:22, labels = as.character(1:22)) +
  labs(
    title = "Sesgo posicional de G→T (spikes) en top-10 miRNAs vs. controles",
    x     = "Posición en el miRNA",
    y     = "Avg G→T count"
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    axis.text.x     = element_text(size = 7),
    plot.title      = element_text(hjust = 0.5, face = "bold")
  )
```

```{r}

# build a spectrum table
spec_df <- snv_long %>%
  filter(ref == "G") %>%                       # only G→X
  mutate(type = case_when(
    alt == "T"      ~ "G→T",
    alt == "A"      ~ "G→A",
    TRUE            ~ "G→C"
  )) %>%
  group_by(treatment, type) %>%
  summarise(count = sum(n_mut), .groups="drop") %>%
  group_by(treatment) %>%
  mutate(prop = count / sum(count)) %>%
  ungroup()

ggplot(spec_df, aes(x = treatment, y = prop, fill = type)) +
  geom_col() +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(
    x = "Treatment",
    y = "% of G→X mutations",
    fill = "Mutation type",
    title = "Mutational spectrum by treatment"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



```{r}
# 1) Summarise total SNVs per sample
total_per_sample <- snv_long %>%
  group_by(sample, treatment) %>%
  summarise(total = sum(n_mut), .groups="drop")

# 2) Compute mean ± SD per treatment
treat_summary <- total_per_sample %>%
  group_by(treatment) %>%
  summarise(
    mean_total = mean(total),
    sd_total   = sd(total),
    n          = n(),
    .groups    = "drop"
  )

# 3) Bar + error‐bar plot
ggplot(treat_summary, aes(x = treatment, y = mean_total)) +
  geom_col(fill = "steelblue") +
  geom_errorbar(aes(ymin = mean_total - sd_total,
                    ymax = mean_total + sd_total),
                width = 0.2) +
  labs(
    x     = "Treatment",
    y     = "Mean total SNVs per sample",
    title = "Overall miRNA SNV burden by treatment\n(mean ± SD across replicates)"
  ) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title  = element_text(hjust = 0.5)
  )
```
```{r}
install.packages("multimiR")
install.packages("clusterProfiler")
install.packages("org.Hs.ef.db")
```

```{r}
library(dplyr)
library(multiMiR)
library(clusterProfiler)
library(org.Hs.eg.db)
library(ggplot2)

# 0) Definir los top-5 tratamientos según total de G→T
top5_treats <- snv_long %>%
  filter(mut_type=="G>T", !is_control) %>%
  group_by(treatment) %>%
  summarise(total_gt = sum(n_mut), .groups="drop") %>%
  slice_max(total_gt, n = 5) %>%
  pull(treatment)

# 1) Para cada tratamiento: 
#    a) saco sus top-10 miRNAs más oxidados
#    b) recupero dianas con multiMiR
#    c) hago enrichGO y dotplot
plots <- lapply(top5_treats, function(trt){
  
  # a) top-10 miRNAs por G→T en este treatment
  top_mir <- snv_long %>%
    filter(mut_type=="G>T", !is_control, treatment==trt) %>%
    group_by(miRNA) %>%
    summarise(n_gt = sum(n_mut), .groups="drop") %>%
    slice_max(n_gt, n = 10) %>%
    pull(miRNA)
  
  # b) dianas
  mm <- get_multimir(org     = "hsa",
                     mirna   = top_mir,
                     summary = TRUE)
  genes <- unique(mm@data$target_symbol)
  
  # c) enriquecimiento GO BP
  ego <- enrichGO(gene         = genes,
                  OrgDb        = org.Hs.eg.db,
                  keyType      = "SYMBOL",
                  ont          = "BP",
                  pAdjustMethod= "BH",
                  qvalueCutoff = 0.05)
  
  # dotplot
  dotplot(ego, showCategory = 10) +
    ggtitle(paste0("GO BP (", trt, ")")) +
    theme_minimal() +
    theme(plot.title = element_text(hjust=0.5, face="bold"))
})


for(p in plots) print(p)
```



```{r}

library(multiMiR)
library(clusterProfiler)
library(org.Hs.eg.db)
library(ggplot2)          # <— make sure ggplot2 is loaded

# 1) Vector de tus top-10 miRNAs por G→T (definido en el chunk anterior)
top_gt_miRNAs <- top_GT$miRNA

# 2) Obtener genes diana (predichos + validados)
mirna_targets <- get_multimir(
  org     = "hsa",
  mirna   = top_gt_miRNAs,
  summary = TRUE
)

# 3) Extraer símbolos de genes objetivos únicos
target_genes <- unique(mirna_targets@data$target_symbol)

# 4) Enriquecimiento GO BP
ego <- enrichGO(
  gene          = target_genes,
  OrgDb         = org.Hs.eg.db,
  keyType       = "SYMBOL",
  ont           = "BP",
  pAdjustMethod = "BH",
  qvalueCutoff  = 0.05
)

# 5) Dotplot de los 10 términos más significativos
dotplot(ego, showCategory = 10) +
  ggtitle("GO BP enrichment for targets of top G→T miRNAs")
```



