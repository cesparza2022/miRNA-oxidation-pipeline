---
title: "mirna-bloodplasma-3"
author: "César Esparza"
date: "2025-05-22"
output: html_document
---

```{r setup}
# Chunk 1: Setup
# Objetivo: Cargar librerías esenciales y definir funciones genéricas para manejo de muestras y grupos.
library(tidyverse)
library(pheatmap)
library(readr)
library(dplyr)
library(ggvenn)
library(stringr)
library(ggplot2)
library(purrr)
library(scales)
library(UpSetR)
library(dynamicTreeCut)
# Función sample_info: asocia muestras a grupos según patrones en sus nombres
sample_info <- function(cols) {
  tibble(sample = cols) %>%
    mutate(group = case_when(
      str_detect(sample, "ALS[-_]longitudinal") ~ "ALS-Longitudinal",
      str_detect(sample, "ALS[-_]enrolment")    ~ "ALS-Enrolment",
      TRUE                                      ~ "Control"
    ))
}
```

```{r data_load}
# Chunk 2: Data Load
# Objetivo: Leer datos y definir columnas de metadatos, totales y SNVs.
df <- read_tsv(
  "/Users/cesaresparza/New_Desktop/UCSD/8OG/results/Magen_ALS-bloodplasma/miRNA_count.Q33.txt",
  col_types = cols()
)
meta_cols  <- c("miRNA name", "pos:mut")
data_cols  <- setdiff(names(df), meta_cols)
total_cols <- grep("\\(PM\\+1MM\\+2MM\\)", data_cols, value = TRUE)
snv_cols   <- setdiff(data_cols, total_cols)

# Generar sample_info para totales y SNVs
sample_info_tot <- sample_info(total_cols)
sample_info_snv <- sample_info(snv_cols)
```

```{r annotation_rpm}
# Chunk 3: Anotación y Normalización (RPM y SNV)
# Objetivo: Extraer recuentos totales, calcular totales por muestra, RPM, y preparar funciones para SNVs.

# Función para recuentos totales (PM rows)
annotate_total_counts <- function(df, cols = total_cols,
                                 miRNA_col = "miRNA name",
                                 mut_col   = "pos:mut") {
  df %>%
    filter(.data[[mut_col]] == "PM") %>%
    select(all_of(c(miRNA_col, cols))) %>%
    rename(miRNA = !!rlang::sym(miRNA_col))
}

# Calcular totales por muestra y añadir fila 'totals'
calculate_total_per_sample <- function(count_df) {
  totals <- count_df %>%
    select(-miRNA) %>%
    summarise(across(everything(), ~ sum(.x, na.rm = TRUE))) %>%
    mutate(miRNA = "totals") %>%
    select(miRNA, everything())
  bind_rows(count_df, totals)
}

# Calcular RPM (reads per million)
calculate_RPM <- function(count_df, miRNA_col = "miRNA", factor = 1e6) {
  denom <- count_df %>%
    filter(.data[[miRNA_col]] == "totals") %>%
    select(-all_of(miRNA_col)) %>%
    unlist(use.names = TRUE)
  count_df %>%
    filter(.data[[miRNA_col]] != "totals") %>%
    mutate(across(-all_of(miRNA_col), ~ .x / denom[cur_column()] * factor))
}

# Filtrar miRNAs frecuentes en RPM con umbral y fracción mínima\
binary_threshold <- function(rpm_df, threshold = 1, min_fraction = 0.10,
                             miRNA_col = "miRNA") {
  samp_cols <- setdiff(names(rpm_df), miRNA_col)
  binary <- rpm_df %>%
    mutate(across(all_of(samp_cols), ~ as.integer(.x >= threshold)))
  n_samps <- length(samp_cols)
  min_samps <- ceiling(n_samps * min_fraction)
  keep <- binary %>%
    mutate(n_ones = rowSums(select(., all_of(samp_cols)))) %>%
    filter(n_ones >= min_samps) %>%
    pull(all_of(miRNA_col))
  list(
    binary_matrix   = binary %>% select(miRNA, all_of(samp_cols)),
    selected_miRNAs = keep
  )
}

# Función para extraer solo filas SNV (mutaciones) y sus conteos
annotate_snv_presence <- function(df, cols = snv_cols,
                                  miRNA_col = "miRNA name",
                                  mut_col   = "pos:mut") {
  df %>%
    filter(.data[[mut_col]] != "PM") %>%
    select(miRNA = .data[[miRNA_col]], mut = .data[[mut_col]], all_of(cols))
  
}


binary_threshold_by_group <- function(rpm_df,
                                      threshold    = 10,
                                      min_fraction = 0.10,
                                      miRNA_col    = "miRNA") {
  # 1) Identificar las columnas de muestras
  samp_cols <- setdiff(names(rpm_df), miRNA_col)
  
  # 2) Generar el data.frame de grupos usando tu función
  groups_df <- sample_info(samp_cols)
  
  # 3) Binarizar: 1 si RPM >= threshold, 0 si no
  binary_df <- rpm_df %>%
    mutate(across(all_of(samp_cols), ~ as.integer(.x >= threshold)))
  
  # 4) Para cada grupo, seleccionar los miRNAs que cumplen el cutoff en ≥ min_fraction de sus muestras
  selected <- character(0)
  for (g in unique(groups_df$group)) {
    cols_g  <- groups_df %>% filter(group == g) %>% pull(sample)
    cols_g  <- intersect(cols_g, samp_cols)
    min_sam <- ceiling(length(cols_g) * min_fraction)
    
    hits_g  <- binary_df %>%
      filter(rowSums(select(., all_of(cols_g))) >= min_sam) %>%
      pull(!!sym(miRNA_col))
    
    selected <- union(selected, hits_g)
  }
  
  # 5) Devolver la matriz binaria y la lista de miRNAs “interesantes”
  list(
    binary_matrix   = binary_df %>% select(all_of(c(miRNA_col, samp_cols))),
    selected_miRNAs = selected
  )
}

# Función que convierte rpm_df en 0/1 según un umbral
binarize_rpm_df <- function(rpm_df,
                            threshold = 10,
                            miRNA_col = "miRNA") {
  rpm_df %>%
    mutate(across(
      .cols = -all_of(miRNA_col),
      .fns  = ~ as.integer(.x >= threshold)
    ))
}

get_significant_miRNAs <- function(binary_df,
                                   min_fraction = 0.15,
                                   miRNA_col    = "miRNA") {
  samp_cols <- setdiff(names(binary_df), miRNA_col)
  # cuántos “1” necesito como mínimo
  min_samps <- ceiling(length(samp_cols) * min_fraction)
  
  # seleccionar los miRNAs cuya fila suma ≥ min_samps
  binary_df %>%
    filter(rowSums(select(., all_of(samp_cols))) >= min_samps) %>%
    pull(!!sym(miRNA_col))
}

```

```{r}
# Chunk 4: Procesamiento de Mutaciones y edgeR
# Objetivo: Expandir y colapsar mutaciones, y preparar matriz para edgeR.

split_mutations <- function(df, mut_col = "pos:mut") {
  df %>%
    separate_rows(.data[[mut_col]], sep = ",") %>%
    mutate(!!mut_col := str_trim(.data[[mut_col]]))
}

collapse_after_split <- function(df, mut_col = "pos:mut") {
  df %>%
    group_by(`miRNA name`, !!sym(mut_col)) %>%
    summarise(
      # 1) Sumamos únicamente los conteos de SNV
      across(all_of(snv_cols), ~ sum(.x, na.rm = TRUE)),
      # 2) Tomamos el primer valor de los conteos totales (son idénticos en cada split)
      across(all_of(total_cols), ~ first(.x)),
      .groups = "drop"
    )
}

collapse_after_split_rpm <- function(df, mut_col = "pos:mut") {
  df %>%
    group_by(`miRNA name`, !!sym(mut_col)) %>%
    summarise(
      # 1) Sumamos únicamente los conteos de SNV
      across(all_of(data_cols_rpm), ~ sum(.x, na.rm = TRUE)),
    )
}



filter_GtoT <- function(df, mut_col = "pos:mut") {
  df %>%
    # 1) eliminar la fila PM si existe
    filter(.data[[mut_col]] != "PM") %>%
    # 2) quedarnos solo con los cambios G→T codificados como “GT”
    filter(str_detect(.data[[mut_col]], "^[0-9]+:GT$"))
}

strip_suffix <- function(x) str_replace(x, "\\s*\\(PM\\+1MM\\+2MM\\)$", "")


convert_to_edgeR <- function(df_collapsed,
                             mut_col     = "pos:mut",
                             snv_cols    = snv_cols,
                             miRNA_col   = "miRNA name") {
  df_DE <- df_collapsed %>%
    # renombra la columna con espacios para trabajar más cómodo
    rename(miRNA_name = !!sym(miRNA_col)) %>%
    # limpia la mutación y crea un featureID único
    mutate(
      clean_mut = str_replace_all(.data[[mut_col]], ":", "_"),
      featureID = paste(miRNA_name, clean_mut, sep = "_")
    ) %>%
    # selecciona sólo la columna featureID + tus snv_cols
    select(featureID, all_of(snv_cols))
  
  # construye la matriz de conteos
  count_mat <- as.matrix(df_DE[snv_cols])
  rownames(count_mat) <- df_DE$featureID
  mode(count_mat) <- "integer"
  
  # chequeos
  stopifnot(!any(is.na(count_mat)))
  message("Dimensions of count_mat: ", paste(dim(count_mat), collapse = " x "))
  
  return(count_mat)
}
```

```{r}
# 1) Extraer solo filas de SNV (no eliminar la fila 'totals' de totales)
annotate_snv_counts <- function(df,
                                cols      = snv_cols,
                                miRNA_col = "miRNA name",
                                mut_col   = "pos:mut") {
  df %>%
    filter(.data[[mut_col]] != "PM") %>%
    select(all_of(c(miRNA_col, mut_col, cols))) %>%
    rename(miRNA = !!rlang::sym(miRNA_col),
           mut   = !!rlang::sym(mut_col))
}

# 2) Calcular frecuencia relativa SNV = SNV_count / total_count_por_muestra
calculate_snv_freq <- function(snv_df,
                               total_counts_df,
                               miRNA_col = "miRNA",
                               factor    = 1) {
  # Sacamos el vector denominador a partir de la fila 'totals'
  denom <- total_counts_df %>%
    filter(.data[[miRNA_col]] == "totals") %>%
    select(-all_of(miRNA_col)) %>%
    unlist(use.names = TRUE)

  # Dividimos cada columna de muestra en snv_df por su total * factor
  snv_df %>%
    # si incluyéramos 'totals' en snv_df, la quitamos:
    filter(.data[[miRNA_col]] != "totals") %>%
    mutate(
      across(
        -all_of(miRNA_col),
        ~ .x / denom[cur_column()] * factor
      )
    )
}
```

```{r exploratory}
# Chunk 5: Exploratory SNVs and miRNAs
# Objective: Stepwise exploration of total counts and SNV prevalence

# 1) Pie chart of sample distribution
counts <- sample_info_tot %>% count(group) %>% deframe()
pie(
  counts,
  labels = paste0(names(counts), " (", counts, ")"),
  main   = "Sample distribution by group"
)

```

```{r exploratory}

# 2) Total counts violin/boxplot
df_tot <- df %>%
  annotate_total_counts() %>%
  calculate_total_per_sample()

# Pivot to long and join group info
df_tot_long <- df_tot %>%
  filter(miRNA == "totals") %>%
  pivot_longer(
    cols      = -miRNA,
    names_to  = "sample",
    values_to = "total_counts"
  ) %>%
  left_join(sample_info_tot, by = "sample")

# Summary stats
stats_by_group <- df_tot_long %>%
  group_by(group) %>%
  summarise(
    n            = n(),
    mean_total   = mean(total_counts),
    median_total = median(total_counts),
    sd_total     = sd(total_counts)
  )
print(stats_by_group)

# Violin + boxplot
ggplot(df_tot_long, aes(x = group, y = total_counts, fill = group)) +
  geom_violin(alpha = 0.4) +
  geom_boxplot(width = 0.3, alpha = 0.6) +
  stat_summary(fun = mean, geom = "point", shape = 23, size = 3, fill = "yellow") +
  labs(
    title = "Total Counts by Sample Group",
    x     = "Group",
    y     = "Total Counts"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

# 3) SNV presence and UpSet
df_presence <- df %>%
  annotate_snv_presence() %>%
  pivot_longer(
    cols      = all_of(snv_cols),
    names_to  = "sample",
    values_to = "count"
  ) %>%
  filter(count > 0) %>%
  left_join(sample_info_snv, by = "sample") %>%
  unite(id, miRNA, mut, sep = "_") %>%
  count(group, id) %>%
  pivot_wider(names_from = group, values_from = n, values_fill = 0)

snv_lists <- map(
  unique(sample_info_tot$group),
  ~ df_presence$id[df_presence[[.x]] > 0]
)
names(snv_lists) <- unique(sample_info_tot$group)
upset(
  fromList(snv_lists),
  nsets      = length(snv_lists),
  keep.order = TRUE,
  order.by   = "freq"
)

# 4) SNV prevalence histograms
df_counts_long <- df_presence %>%
  pivot_longer(-id, names_to = "group", values_to = "n_samples")

# Overlay histog rg
 ggplot(df_counts_long, aes(x = n_samples, fill = group)) +
  geom_histogram(position = "identity", alpha = 0.4, binwidth = 1) +
  labs(
    title = "SNV Prevalence by Group",
    x     = "# Samples per variant",
    y     = "# SNVs"
  ) +
  theme_minimal()

# Faceted histogram
 ggplot(df_counts_long, aes(x = n_samples, fill = group)) +
  geom_histogram(binwidth = 5, alpha = 0.7) +
  facet_wrap(~ group, scales = "free_y") +
  labs(
    title = "SNV Frequency Distributions",
    x     = "# Samples per variant",
    y     = "# SNVs"
  ) +
  theme_minimal()

# 5) Binned SNV prevalence by group
bin_labels <- c("1-10", "11-50", "51-100", "101-250", ">250")
binned_counts <- df_counts_long %>%
  filter(n_samples > 0) %>%
  mutate(bin = cut(
    n_samples, breaks = c(0, 10, 50, 100, 250, Inf),
    labels = bin_labels, right = TRUE
  )) %>%
  group_by(group, bin) %>%
  summarise(n_variants = n(), .groups = "drop")

binned_counts$bin <- factor(binned_counts$bin, levels = bin_labels)

ggplot(binned_counts, aes(x = bin, y = n_variants, fill = group)) +
  geom_col(position = "dodge") +
  scale_y_log10(labels = scales::comma) +
  labs(
    title = "SNV Prevalence Bins by Group",
    x     = "Prevalence bin (# samples where variant appears)",
    y     = "Number of Variants (log10)"
  ) +
  theme_minimal()
```

Este pedazo lo que hace es primero sacar las cuentas totales por miRNA por sample, luego agrega la columna de totales, luego calcula el rpm por miRNA por muestra, luego hace una versión acomodada de forma distinta para los totales, luego acomoda el RPM de esta forma, y ya luego define los filtros para 1000 de cuentas totales del miRNA en la muestra y que el RPM del miRNA en la muestra sea de al menos 10%

```{r}
# 1) Totales y RPM (una sola vez)
tot_counts             <- annotate_total_counts(
  df,
  cols      = total_cols,
  miRNA_col = "miRNA name",
  mut_col   = "pos:mut"
)

tot_counts_with_totals <- calculate_total_per_sample(tot_counts)


rpm_df                 <- calculate_RPM(
  count_df  = tot_counts_with_totals,
  miRNA_col = "miRNA",
  factor    = 1e6
)

```


```{r}
# 2) Formato largo de totales
tot_long <- tot_counts %>%
  pivot_longer(
    cols      = -miRNA,
    names_to  = "sample_raw",
    values_to = "total_count"
  ) %>%
  mutate(
    sample = str_remove(sample_raw, fixed("(PM+1MM+2MM)")) %>% str_trim()
  ) %>%
  select(miRNA, sample, total_count)

# 3) Formato largo de RPM
rpm_long <- rpm_df %>%
  pivot_longer(
    cols      = -miRNA,
    names_to  = "sample_raw",
    values_to = "rpm_value"
  ) %>%
  mutate(
    sample = str_remove(sample_raw, fixed("(PM+1MM+2MM)")) %>% str_trim()
  )

# 4) Unión y filtrado (Variante B: ≥10% en algún grupo)
threshold_total <- 1000
rpm_long2 <- rpm_long %>%
  left_join(tot_long, by = c("miRNA", "sample")) %>%
  filter(rpm_value >= 10, total_count >= threshold_total)

# 5) Asociar grupos y calcular frac_present
sample_info_clean <- sample_info_tot %>%
  mutate(sample = str_remove(sample, fixed("(PM+1MM+2MM)")) %>% str_trim()) %>%
  select(sample, group)

rpm_long2 <- rpm_long2 %>%
  left_join(sample_info_clean, by = "sample") %>%
  filter(!is.na(group))

miRNA_presence_by_group <- rpm_long2 %>%
  group_by(group, miRNA) %>%
  summarise(n_present = n_distinct(sample), .groups = "drop")

group_sizes <- sample_info_clean %>%
  distinct(group, sample) %>%
  group_by(group) %>%
  summarise(n_samples = n(), .groups = "drop")

miRNA_group_stats <- miRNA_presence_by_group %>%
  left_join(group_sizes, by = "group") %>%
  mutate(frac_present = n_present / n_samples)

# 6) Variante B: ≥ 10% en algún grupo
miRNAs_keep_anyGroup <- miRNA_group_stats %>%
  filter(frac_present >= 0.10) %>%
  pull(miRNA) %>%
  unique()

cat("MiRNAs que cumplen ≥10% en algún grupo:", length(miRNAs_keep_anyGroup), "\n")

```

Aquí voy a hacer mi experimento de filtrado por grupo, lo que hace distino es que la función en la que tomo la matriz de RPM la filtro por que sean los RPM \>10 pero para pasar el filtro tienen que estar en al menos 10% de las muestras de uno de los grupos, mientras que en el otro es en el 20% total

```{r}
binary_rpm_df <- binarize_rpm_df(rpm_df, threshold = 40, miRNA_col = "miRNA")

# 2.1) Columnas de enrolment (ALS-Enrolment)
cols_enrol <- grep("ALS[-_]enrolment", names(binary_rpm_df), value = TRUE)
binary_rpm_enrolment <- binary_rpm_df %>% select(miRNA, all_of(cols_enrol))

# 2.2) Columnas de longitudinal (ALS-Longitudinal)
cols_long  <- grep("ALS[-_]longitudinal", names(binary_rpm_df), value = TRUE)
binary_rpm_longitudinal <- binary_rpm_df %>% select(miRNA, all_of(cols_long))

# 2.3) Control (el resto de columnas excepto miRNA)
cols_ctrl  <- setdiff(names(binary_rpm_df)[-1], c(cols_enrol, cols_long))
binary_rpm_control <- binary_rpm_df %>% select(miRNA, all_of(cols_ctrl))
```

```{r}
nrow(binary_rpm_df)
```


```{r}
# Ejecución para cada grupo (min_fraction=15%):
sig_enrol    <- get_significant_miRNAs(binary_rpm_enrolment,    min_fraction = 0.20)
sig_long     <- get_significant_miRNAs(binary_rpm_longitudinal, min_fraction = 0.20)
sig_control  <- get_significant_miRNAs(binary_rpm_control,      min_fraction = 0.20)
```

```{r}
# Resultado: vectores con nombres de miRNAs
sig_enrol    # ALS-Enrolment
sig_long     # ALS-Longitudinal
sig_control  # Control
```

```{r}

# 1) Compute the seven overlap sets in English
only_enrol       <- setdiff(sig_enrol,     union(sig_long,   sig_control))
only_long        <- setdiff(sig_long,      union(sig_enrol,  sig_control))
only_ctrl        <- setdiff(sig_control,   union(sig_enrol,  sig_long))
enrol_long       <- setdiff(intersect(sig_enrol, sig_long),   sig_control)
enrol_ctrl       <- setdiff(intersect(sig_enrol, sig_control), sig_long)
long_ctrl        <- setdiff(intersect(sig_long,  sig_control), sig_enrol)
all_three        <- Reduce(intersect, list(sig_enrol, sig_long, sig_control))

# 2) Build a counts data frame
counts_df <- tibble(
  category = c(
    "Only Enrolment", "Only Longitudinal", "Only Control",
    "Enrolment & Longitudinal", "Enrolment & Control", "Longitudinal & Control",
    "All Three"
  ),
  count = c(
    length(only_enrol), length(only_long), length(only_ctrl),
    length(enrol_long), length(enrol_ctrl), length(long_ctrl),
    length(all_three)
  )
) %>%
  filter(count > 0)

# 3) Plot pie chart with only the counts inside slices
ggplot(counts_df, aes(x = "", y = count, fill = category)) +
  geom_col(width = 1, color = "white") +          # white borders between slices
  coord_polar(theta = "y") +                      # make it a pie
  geom_text(aes(label = count),                   # only the number
            position = position_stack(vjust = 0.5),
            size = 3) +
  theme_void() +                                  # no background or axes
  labs(
    title = "Distribution of miRNAs by Overlap Categories",
    fill  = "Category"                            # legend title
  ) +
  theme(
    plot.title      = element_text(hjust = 0.5),  # center the title
    legend.position = "right"                     # legend on the right
  )
```

```{r}
nrow(rpm_df)
```

```{r}
(all_three)
```

```{r}

# 2) Vector con tus miRNAs de interés
top_miRNAs <- all_three

# 3) Filtrar filas y reordenar columnas
df_top_rpm <- df %>%
  filter(`miRNA name` %in% top_miRNAs) %>%
  select(
    all_of(meta_cols),   # metadatos primero
    all_of(snv_cols),    # luego conteos de SNV
    all_of(total_cols)   # por último conteos totales
  )

# Ahora df_filtered tiene exactamente tu formato original,
# pero solo con las filas (SNVs) de los miRNAs que pasaron tu filtro.

```

```{r}
# Asegúrate de que ambas listas sean vectores únicos
top_10_miRNAs <- unique(top_10_miRNAs)
all_three     <- unique(all_three)

# Intersección
miRNAs_comunes <- intersect(top_10_miRNAs, all_three)

# Cuantificar
n_comunes      <- length(miRNAs_comunes)
n_top          <- length(top_10_miRNAs)
n_all_three    <- length(all_three)

cat("Coinciden", n_comunes, "miRNAs\n")
cat("Proporción del top_10_miRNAs que están en all_three:", round(100 * n_comunes / n_top, 2), "%\n")
cat("Proporción de all_three que están en top_10_miRNAs:", round(100 * n_comunes / n_all_three, 2), "%\n")
```

```{r}
library(eulerr)

# Asegura vectores únicos
top_10_miRNAs <- unique(top_10_miRNAs)
all_three     <- unique(all_three)

# Intersecciones
intersec <- intersect(top_10_miRNAs, all_three)

# Elementos únicos en cada grupo
only_top <- setdiff(top_10_miRNAs, all_three)
only_all <- setdiff(all_three, top_10_miRNAs)

# Crear objeto euler
venn_fit <- euler(c(
  "10% SNV" = length(only_top),
  "RPM>40" = length(only_all),
  "10% SNV&RPM>40" = length(intersec)
))

# Dibujar
plot(
  venn_fit,
  fills = list(fill = c("cornflowerblue", "darkseagreen3"), alpha = 0.6),
  labels = list(font = 2),
  quantities = TRUE,
  main = "SNV Reads filtering vs Expression filtering "
)
```



aquí lo que hago es filtrar mi df original para usar solo los miRNAs que salieron con el método de Alex
```{r}

# 3) Filtrar filas y reordenar columnas
df_alex <- df %>%
  filter(`miRNA name` %in% top_10_miRNAs) %>%
  select(
    all_of(meta_cols),   # metadatos primero
    all_of(snv_cols),    # luego conteos de SNV
    all_of(total_cols)   # por último conteos totales
  )

```



```{r}

```

aquí empieza la parte del sacar los dfs con los formatos para lo de las gráfias por posición 

```{r}
# 1. Expandimos los SNVs si hay múltiples mutaciones separadas por coma
df_alex_split_og <- split_mutations(df)

# 2. Agrupamos por miRNA y mutación, sumamos SNVs, y conservamos un total representativo
df_collapsed_og <- collapse_after_split(df_alex_split)

df_gt_alex_og <- filter_GtoT(df_collapsed)
```


```{r}
TOT_SUFFIX_REGEX <- "\\s*\\(PM\\+1MM\\+2MM\\)\\s*$"

# ¿Se colaron columnas TOTAL en tu lista de SNV?
cat("¿TOTAL en keep_snv_cols_ALS?:\n")
print(table(grepl(TOT_SUFFIX_REGEX, keep_snv_cols_ALS)))

# ¿Cómo estás comparando en el setdiff?
cat("\nEjemplo de 5 nombres en cada lado:\n")
print(head(keep_snv_cols_ALS, 5))
print(head(names(Lj_vec_ALS), 5))  # OJO: ya están strippeados en tu código

# Muestra los “faltantes” como los ves ahora:
missing_raw <- setdiff(keep_snv_cols_ALS, names(Lj_vec_ALS))
cat("\nFaltantes (como los ves ahora):\n")
print(missing_raw[1:min(10, length(missing_raw))])

# Muestra los “faltantes” comparando BASE vs BASE:
missing_base <- setdiff(
  stringr::str_replace(stringr::str_squish(keep_snv_cols_ALS), TOT_SUFFIX_REGEX, ""),
  names(Lj_vec_ALS)  # ya está sin sufijo
)
cat("\nFaltantes comparando BASE vs BASE:\n")
print(missing_base[1:min(10, length(missing_base))])
```




aquí vamos a separar para solo usar los datos de ALS

```{r}
# Patrones que quieres conservar
pat_keep_ALS <- "(ALS[-_]enrolment|ALS[-_]longitudinal)"
TOT_SUFFIX_REGEX <- "\\s*\\(PM\\+1MM\\+2MM\\)\\s*$"

## 1) Columnas SNV (cuentas de SNV)
keep_snv_cols_ALS <- snv_cols[str_detect(snv_cols, pat_keep_ALS)]
# (FIX 1) Asegura que aquí NO se cuele ninguna columna TOTAL con sufijo:
keep_snv_cols_ALS <- keep_snv_cols_ALS[!grepl(TOT_SUFFIX_REGEX, keep_snv_cols_ALS)]

## 2) Columnas TOTAL (PM+1MM+2MM)
# Primero quitamos el sufijo para poder detectar el mismo nombre de sample
base_tot_names <- str_replace(total_cols, TOT_SUFFIX_REGEX, "")
keep_total_cols_ALS <- total_cols[str_detect(base_tot_names, pat_keep_ALS)]

## 3) Subset del data frame original
df_collapsed_ALS <- df_collapsed %>%
  dplyr::select(dplyr::all_of(meta_cols),
                dplyr::all_of(keep_snv_cols_ALS),
                dplyr::all_of(keep_total_cols_ALS))
```


ahora vamos a hacer este pedo pero para la parte de los RPMs como estamos sacando acá



```{r}
# totales por muestra para cada miRNA (PM+1MM+2MM); una fila por miRNA
df_mirna_tot_ALS <- df_collapsed_ALS %>%
  dplyr::distinct(`miRNA name`, .keep_all = TRUE) %>%
  dplyr::select(`miRNA name`, dplyr::all_of(keep_total_cols_ALS))
```

```{r}
df_alex_noPM_ALS <- df_collapsed_ALS %>%
  dplyr::filter(`pos:mut` != "PM")
```


```{r}
Lj_vec_ALS <- df %>%
  dplyr::summarise(dplyr::across(dplyr::all_of(keep_total_cols_ALS), ~ sum(.x, na.rm = TRUE))) %>%
  unlist()
```

```{r}
# Nombra el vector de denominadores con NOMBRES BASE (sin sufijo)
names(Lj_vec_ALS) <- stringr::str_replace(names(Lj_vec_ALS), TOT_SUFFIX_REGEX, "")
```


```{r}
# (FIX 2) Chequeo en el MISMO dominio (base vs base)
missing_in_Lj_ALS <- setdiff(
  stringr::str_replace(keep_snv_cols_ALS, TOT_SUFFIX_REGEX, ""),
  names(Lj_vec_ALS)
)
if (length(missing_in_Lj_ALS))
  stop("Estas columnas no tienen denominador en Lj_vec: ",
       paste(missing_in_Lj_ALS, collapse = ", "))
```

```{r}
snv_mat_ALS      <- as.matrix(df_alex_noPM_ALS[keep_snv_cols_ALS])
denominators_ALS <- Lj_vec_ALS[keep_snv_cols_ALS]   # mismos nombres, mismo orden

rpm_mat_alex_ALS <- sweep(snv_mat_ALS, 2, denominators_ALS, "/") * 1e6
colnames(rpm_mat_alex_ALS) <- paste0(colnames(rpm_mat_alex_ALS), "_RPM")

df_rpm_alex_ALS <- bind_cols(df_alex_noPM_ALS[, meta_cols], as.data.frame(rpm_mat_alex_ALS))
```

```{r}
df_rpm_alex_ALS <- df_rpm_alex_ALS %>%
  rename(miRNA_name = `miRNA name`) %>%
  mutate(
    clean_mut = str_replace(`pos:mut`, ":", "_"),
    featureID = paste(miRNA_name, clean_mut, sep = "_"),
    pos = as.integer(str_extract(clean_mut, "^[0-9]+"))
  )
```


```{r}
rpm_cols_ALS <- grep("_RPM$", names(df_rpm_alex_ALS), value = TRUE)
```

```{r}
df_avr_ALS <- df_rpm_alex_ALS %>%
  mutate(avr_raw = rowMeans(across(all_of(rpm_cols_ALS)), na.rm = TRUE)) %>%
  filter(avr_raw > 0) %>%
  mutate(avr = log2(avr_raw + 1)) %>%
  select(featureID, miRNA_name, pos, avr)
```


```{r}
df_ranked_ALS <- df_avr_ALS %>%
  group_by(pos) %>%
  arrange(desc(avr), .by_group = TRUE) %>%
  mutate(order_within_pos = row_number()) %>%
  ungroup()
```



REPE 2
\

para el df de control, es lo mismo para el de ALS pero con el dataset de ALS 
```{r}
# -------- CONTROL (CTRL) --------
pat_keep_CTRL <- "(?i)control"
TOT_SUFFIX_REGEX <- "\\s*\\(PM\\+1MM\\+2MM\\)\\s*$"
strip_suffix <- function(x) stringr::str_replace(stringr::str_squish(x), TOT_SUFFIX_REGEX, "")

## 1) Columnas SNV (cuentas) y TOTAL derivadas del DF actual
# (re-derivamos desde df_gt para evitar contaminación)
total_cols <- grep(TOT_SUFFIX_REGEX, names(df_gt), value = TRUE)
snv_cols   <- setdiff(names(df_gt), c(meta_cols, total_cols))

# Filtra solo columnas de muestras CONTROL
keep_snv_cols   <- snv_cols[stringr::str_detect(snv_cols, pat_keep_CTRL)]
base_tot_names  <- strip_suffix(total_cols)
keep_total_cols <- total_cols[stringr::str_detect(base_tot_names, pat_keep_CTRL)]

# Subset del data frame original
df_collapsed <- df_gt %>%
  dplyr::select(dplyr::all_of(meta_cols),
                dplyr::all_of(keep_snv_cols),
                dplyr::all_of(keep_total_cols))
```



```{r}
# totales por muestra para cada miRNA (PM+1MM+2MM); una fila por miRNA
df_mirna_tot_alex <- df_collapsed %>%
  dplyr::distinct(`miRNA name`, .keep_all = TRUE) %>%   # evita duplicados por SNV
  dplyr::select(`miRNA name`, dplyr::all_of(keep_total_cols))
```

```{r}
# quita filas PM (perfect match) de las cuentas de SNV
df_alex_noPM <- df_collapsed %>%
  dplyr::filter(`pos:mut` != "PM")
```


```{r}
# vector de library size por muestra (CONTROL)
Lj_vec <- df  %>%
  dplyr::summarise(dplyr::across(dplyr::all_of(keep_total_cols), ~ sum(.x, na.rm = TRUE))) %>%
  unlist()

# nombra en dominio BASE (sin sufijo) para poder indexar con columnas SNV
names(Lj_vec) <- strip_suffix(names(Lj_vec))
```

```{r}
# Chequeo rápido de nombres (BASE vs BASE)
missing_in_Lj <- setdiff(strip_suffix(keep_snv_cols), names(Lj_vec))
if (length(missing_in_Lj))
  stop("Estas columnas no tienen denominador en Lj_vec (CTRL): ",
       paste(missing_in_Lj, collapse = ", "))
```

```{r}
snv_mat      <- as.matrix(df_alex_noPM[keep_snv_cols])
denominators <- Lj_vec[keep_snv_cols]   # mismos nombres, mismo orden

rpm_mat_alex <- sweep(snv_mat, 2, denominators, "/") * 1e6
colnames(rpm_mat_alex) <- paste0(colnames(rpm_mat_alex), "_RPM")

df_rpm_alex <- bind_cols(df_alex_noPM[, meta_cols], as.data.frame(rpm_mat_alex))
```

```{r}
df_rpm_alex <- df_rpm_alex %>%
  rename(miRNA_name = `miRNA name`) %>%
  mutate(
    clean_mut = str_replace(`pos:mut`, ":", "_"),
    featureID = paste(miRNA_name, clean_mut, sep = "_"),
    pos = as.integer(str_extract(clean_mut, "^[0-9]+"))
  )
```


```{r}
rpm_cols <- grep("_RPM$", names(df_rpm_alex), value = TRUE)
```

```{r}
df_avr <- df_rpm_alex %>%
  mutate(avr_raw = rowMeans(across(all_of(rpm_cols)), na.rm = TRUE)) %>%
  filter(avr_raw > 0) %>%
  mutate(avr = log2(avr_raw + 1)) %>%
  select(featureID, miRNA_name, pos, avr)
```


```{r}
df_ranked <- df_avr %>%
  group_by(pos) %>%
  arrange(desc(avr), .by_group = TRUE) %>%
  mutate(order_within_pos = row_number()) %>%
  ungroup()
```


gráfica de la parte de control contra ALS

```{r}
library(dplyr)

# 1) Contar por posición en cada grupo
pos_ctrl <- df_ranked %>%
  count(pos, name = "n_ctrl")

pos_als  <- df_ranked_ALS %>%
  count(pos, name = "n_als")

# 2) Totales globales
tot_ctrl <- sum(pos_ctrl$n_ctrl)
tot_als  <- sum(pos_als$n_als)

# 3) Unir y calcular fracciones
pos_df <- full_join(pos_ctrl, pos_als, by = "pos") %>%
  replace_na(list(n_ctrl = 0, n_als = 0)) %>%
  mutate(
    frac_ctrl = n_ctrl / tot_ctrl,
    frac_als  = n_als  / tot_als
  )

# 4) Test de Fisher para cada posición
pos_df <- pos_df %>%
  rowwise() %>%
  mutate(
    p = fisher.test(
      matrix(
        c(n_als,
          tot_als - n_als,
          n_ctrl,
          tot_ctrl - n_ctrl),
        nrow = 2
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p, method = "BH"))

# Resultado
pos_df
```

```{r}
# Preparamos formato largo
plot_df <- pos_df %>%
  select(pos, frac_ctrl, frac_als, p_adj) %>%
  pivot_longer(
    cols = c(frac_ctrl, frac_als),
    names_to  = "group",
    values_to = "fraction"
  ) %>%
  mutate(
    group = recode(group,
                   frac_ctrl = "Control",
                   frac_als  = "ALS")
  )

# Nivel máximo para la sombra
ymax <- max(plot_df$fraction) * 1.1

ggplot(plot_df, aes(x = pos, y = fraction, fill = group)) +
  # 1) Sombra de la región seed (pos 2–6)
  annotate(
    "rect",
    xmin = 2 - 0.5, xmax = 6 + 0.5,
    ymin = 0,       ymax = ymax,
    fill = "grey80", alpha = 0.3, inherit.aes = FALSE
  ) +
  # 2) Barras lado a lado
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  # 3) Asteriscos solo donde p_adj < 0.05
  geom_text(
    data = filter(plot_df, group == "ALS" & p_adj < 0.05),
    aes(label = "*"),
    position = position_nudge(x = 0.2),
    vjust = -0.5, size = 5, color = "black"
  ) +
  scale_x_continuous(
    breaks = 1:23,
    minor_breaks = NULL
  ) +
  scale_fill_manual(values = c("Control" = "grey60", "ALS" = "#D62728")) +
  labs(
    x = "Position",
    y = "Positional fraction",
    fill = NULL,
    title = "comparing G>T distribution by position in ALS v.s. control",
    subtitle = "Control vs ALS (seed region shadowed, *p_adj<0.05)"
  ) +
  coord_cartesian(ylim = c(0, ymax)) +
  theme_classic(base_size = 14) +
  theme(
    axis.text.x  = element_text(size = 10),
    legend.position = c(0.8, 0.9)
  )
```

a ver, creo que un par de heatmaps para ver los GTs en la región 




```{r}
library(viridis)
library(dplyr)
library(tidyr)
library(stringr)
library(ComplexHeatmap)
library(circlize)
library(grid)

build_vaf_heatmap <- function(df, meta_cols, zscore = TRUE, min_total = 500,
                              pat_ALS = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                              pat_CTRL = "(?i)control") {
  
  total_cols <- grep("\\(PM\\+1MM\\+2MM\\)$", colnames(df), value = TRUE)
  snv_cols <- setdiff(colnames(df), c(meta_cols, total_cols))
  
  clean_sample <- function(x) str_remove(x, fixed(" (PM+1MM+2MM)"))
  
  df_proc <- df %>%
  rename(miRNA_name = `miRNA name`) %>%
  mutate(
    pos = as.numeric(str_extract(`pos:mut`, "^[0-9]+")),  # <- extrae la posición como número
    clean_mut = str_replace(`pos:mut`, ":", "_"),
    featureID = paste(miRNA_name, clean_mut, sep = "_")
  ) %>%
  filter(pos >= 2 & pos <= 7)  # <- filtra solo región semilla

  # Derretimos en formato largo
  snv_long <- df_proc %>%
    select(featureID, miRNA_name, all_of(snv_cols)) %>%
    pivot_longer(cols = -c(featureID, miRNA_name), names_to = "sample", values_to = "snv_count") %>%
    mutate(sample_clean = clean_sample(sample), sample_type = "snv")

  tot_long <- df_proc %>%
    select(featureID, miRNA_name, all_of(total_cols)) %>%
    pivot_longer(cols = -c(featureID, miRNA_name), names_to = "sample", values_to = "total_count") %>%
    mutate(sample_clean = clean_sample(sample), sample_type = "total")

  # Unimos por sample original, clean y featureID
  df_vaf <- left_join(
    snv_long,
    tot_long,
    by = c("featureID", "sample_clean", "miRNA_name"),
    suffix = c("_snv", "_total")
  ) %>%
    mutate(
      total_count = replace_na(total_count, 0),
      snv_count = replace_na(snv_count, 0),
      vaf = ifelse(total_count >= min_total, snv_count / total_count, 0),
      vaf = pmin(vaf, 1), # asegura que VAF nunca pase de 1
      vaf = replace_na(vaf, 0)
    )

  # Matriz para heatmap
  mat_vaf <- df_vaf %>%
    select(featureID, sample_clean, vaf) %>%
    pivot_wider(names_from = sample_clean, values_from = vaf, values_fill = 0) %>%
    column_to_rownames("featureID") %>%
    as.matrix()

  # Filtra SNVs con algo de señal
  mat_vaf <- mat_vaf[rowMeans(mat_vaf) > 0, , drop = FALSE]


  if (zscore) {
    mat_scaled <- t(scale(t(mat_vaf)))
    mat_scaled[is.na(mat_scaled)] <- 0
    mat_plot <- mat_scaled
    title_label <- "VAF z-score"
    colormap <- colorRamp2(c(-2, 0, 2), c("#4575b4", "white", "#d73027"))
  } else {
    mat_plot <- mat_vaf * 100
    title_label <- "VAF proportion (%)"
    colormap <- colorRamp2(c(0, 0.75, 1.5), c("white", "#fcae91", "red"))  # 0.75% y 1.5%
  }

  # Chequeo de matriz vacía
  if (nrow(mat_plot) == 0 || ncol(mat_plot) == 0) {
    stop("❌ Empty matrix after filtering. No SNVs or samples passed thresholds.")
  }

  message("✅ Matrix: ", nrow(mat_plot), " GTs across seed regions in miRNAs: ALS V.S. control ", ncol(mat_plot), " samples.")

  col_group <- case_when(
    str_detect(colnames(mat_plot), pat_ALS) ~ "ALS",
    str_detect(colnames(mat_plot), pat_CTRL) ~ "Control",
    TRUE ~ "Other"
  )

  col_ha <- HeatmapAnnotation(
    Group = col_group,
    col = list(Group = c("ALS" = "#D62728", "Control" = "grey60", "Other" = "grey90")),
    show_annotation_name = FALSE
  )

  ht <- Heatmap(
    mat_plot,
    name = title_label,
    col = colormap,
    top_annotation = col_ha,
    cluster_rows = TRUE,
    cluster_columns = TRUE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    column_title = paste0(title_label, ":GTs in ALS V.S. control ")
  )

  draw(ht, heatmap_legend_side = "right")

}
```

```{r}
build_vaf_heatmap(df_gt_alex, meta_cols, zscore = T, min_total = 500)
```


```{r}
process_vaf_matrix <- function(df, meta_cols, min_total = 300,
                               pat_ALS = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                               pat_CTRL = "(?i)control") {
  
  total_cols <- grep("\\(PM\\+1MM\\+2MM\\)$", colnames(df), value = TRUE)
  snv_cols <- setdiff(colnames(df), c(meta_cols, total_cols))
  clean_sample <- function(x) str_remove(x, fixed(" (PM+1MM+2MM)"))
  
  df_proc <- df %>%
    rename(miRNA_name = `miRNA name`) %>%
    mutate(
      pos = as.numeric(str_extract(`pos:mut`, "^[0-9]+")),
      clean_mut = str_replace(`pos:mut`, ":", "_"),
      featureID = paste(miRNA_name, clean_mut, sep = "_")) %>% filter(pos >= 2 & pos <= 7)

  snv_long <- df_proc %>%
    select(featureID, miRNA_name, all_of(snv_cols)) %>%
    pivot_longer(cols = -c(featureID, miRNA_name), names_to = "sample", values_to = "snv_count") %>%
    mutate(sample_clean = clean_sample(sample))

  tot_long <- df_proc %>%
    select(featureID, miRNA_name, all_of(total_cols)) %>%
    pivot_longer(cols = -c(featureID, miRNA_name), names_to = "sample", values_to = "total_count") %>%
    mutate(sample_clean = clean_sample(sample))

  df_vaf <- left_join(
    snv_long, tot_long,
    by = c("featureID", "miRNA_name", "sample_clean")
  ) %>%
    mutate(
      total_count = replace_na(total_count, 0),
      snv_count = replace_na(snv_count, 0),
      vaf = ifelse(total_count >= min_total, snv_count / total_count, 0),
      vaf = pmin(vaf, 1),
      vaf = replace_na(vaf, 0)
    )

  mat_vaf <- df_vaf %>%
    select(featureID, sample_clean, vaf) %>%
    pivot_wider(names_from = sample_clean, values_from = vaf, values_fill = 0) %>%
    column_to_rownames("featureID") %>%
    as.matrix()

  mat_vaf <- mat_vaf[rowMeans(mat_vaf) > 0, , drop = FALSE]

  if (nrow(mat_vaf) == 0 || ncol(mat_vaf) == 0) {
    stop("❌ Empty matrix after filtering. No SNVs or samples passed thresholds.")
  }

  message("✅ Matrix: ", nrow(mat_vaf), " GTs across seed regions in miRNAs: ALS V.S. control ", ncol(mat_vaf), " samples.")

  list(
    matrix = mat_vaf,
    df_vaf = df_vaf,
    pat_ALS = pat_ALS,
    pat_CTRL = pat_CTRL
  )
}
```

```{r}
plot_vaf_heatmap <- function(mat_vaf, zscore = TRUE,
                             pat_ALS = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                             pat_CTRL = "(?i)control") {
  
  if (zscore) {
    mat_scaled <- t(scale(t(mat_vaf)))
    mat_scaled[is.na(mat_scaled)] <- 0
    mat_plot <- mat_scaled
    title_label <- "VAF z-score ALS vs control"
    colormap <- colorRamp2(c(-2, 0, 2), c("#4575b4", "white", "#d73027"))
  } else {
    mat_plot <- mat_vaf * 100
    title_label <- "VAF proportion (%)"
    colormap <- colorRamp2(c(0, 0.75, 1.5), c("white", "#fcae91", "red"))
  }

  col_group <- case_when(
    str_detect(colnames(mat_plot), pat_ALS) ~ "ALS",
    str_detect(colnames(mat_plot), pat_CTRL) ~ "Control",
    TRUE ~ "Other"
  )

  col_ha <- HeatmapAnnotation(
    Group = col_group,
    col = list(Group = c("ALS" = "#D62728", "Control" = "grey60", "Other" = "grey90")),
    show_annotation_name = FALSE
  )

  ht <- Heatmap(
    mat_plot,
    name = title_label,
    col = colormap,
    top_annotation = col_ha,
    cluster_rows = TRUE,
    cluster_columns = TRUE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    column_title = paste0(title_label, ": GTs ")
  )

  draw(ht, heatmap_legend_side = "right")
}
```


```{r}
library(dplyr)
library(tidyr)
library(stringr)
library(ComplexHeatmap)
library(circlize)
library(grid)

# 0) Asegura lista limpia
#top_10_miRNAs <- unique(na.omit(top_10_miRNAs))

# 1) Filtra tu df (ya GT) por los miRNAs del top
#df_gt_top <- df_gt_alex %>%
 # dplyr::filter(`miRNA name` %in% top_10_miRNAs)

# 2) Procesa y grafica
vaf_result_seed <- process_vaf_matrix(df_gt_top_top, meta_cols, min_total = 500)
plot_vaf_heatmap(vaf_result_seed$matrix, zscore = F,
                 pat_ALS = vaf_result_seed$pat_ALS,
                 pat_CTRL = vaf_result_seed$pat_CTRL)
```




```{r}
df_totals <- df_gt_alex %>%
  select(miRNA = `miRNA name`, all_of(total_cols)) %>%
  distinct() %>%                                          # 1 fila por miRNA
  mutate(avg_total = rowMeans(across(all_of(total_cols)), na.rm = TRUE))

# 2) Lista de miRNAs que pasan el umbral de expresión
high_expr_miRNAs <- df_totals %>%
  filter(avg_total > 500) %>%
  arrange(desc(avg_total)) %>%
  pull(miRNA)

length(high_expr_miRNAs) 
```



```{r}
df_gt_high <- df_gt_alex %>%
  filter(`miRNA name` %in% high_expr_miRNAs)
```






```{r}
# 1) Resumen por miRNA: media log2ratio en pos 2–6
miRNA_summary <- heat_df %>%
  group_by(miRNA_name) %>%
  summarise(mean_lr = mean(log2ratio, na.rm=TRUE)) %>%
  ungroup()

# 2) Top 10 ALS-enriquecidos (+) y Top 10 Control-enriquecidos (–)
top_als   <- miRNA_summary %>% arrange(desc(mean_lr)) %>% slice_head(n = 10)
top_ctrl  <- miRNA_summary %>% arrange(mean_lr)        %>% slice_head(n = 10)
sel_mirnas <- c(top_ctrl$miRNA_name, top_als$miRNA_name)

# 3) Subset del heatmap y factorización para orden
heat_sel <- heat_df %>%
  filter(miRNA_name %in% sel_mirnas) %>%
  mutate(
    miRNA_name = factor(miRNA_name, levels = rev(sel_mirnas))
  )

# 4) Dibujo
ggplot(heat_sel, aes(x = pos, y = miRNA_name, fill = log2ratio)) +
  geom_tile(color = "grey80", size = 0.2) +
  scale_fill_gradient2(
    low  = "#4575b4",
    mid  = "white",
    high = "#d73027",
    midpoint = 0,
    limits = c(-2, 2),
    oob = scales::squish,
    name = expression(log[2]~frac(ALS+1,Control+1))
  ) +
  labs(
    x     = "Position in seed",
    y     = NULL,
    title = "Heatmap de SNVs en seed (pos 2–6)",
    subtitle = "Top 10 miRNAs enriquecidos en Control (arriba) y en ALS (abajo)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.y     = element_text(size = 8),
    axis.text.x     = element_text(face = "bold"),
    panel.grid      = element_blank(),
    legend.title    = element_text(size = 9),
    legend.text     = element_text(size = 7),
    plot.subtitle   = element_text(size = 10, face = "italic")
  )
```







Gráficas originales


```{r}
library(dplyr)
library(tidyr)
library(stringr)
library(ComplexHeatmap)
library(circlize)
library(grid)

# Paso 1: Encontrar el máximo número de SNVs en cualquier posición
df_summary <- df_ranked %>%
  group_by(pos) %>%
  summarise(total_snvs = n()) %>%
  ungroup()

max_snvs <- max(df_summary$total_snvs)

# Paso 2: Crear matrices con el mismo número de filas (rellenando con NA)
matrix_list <- list()

positions <- sort(unique(df_ranked$pos)) # Asegurar orden numérico

for (p in positions) {
  snvs_for_pos <- df_ranked %>%
    filter(pos == p) %>%
    arrange(desc(avr)) %>%  # Orden descendente por avr
    pull(avr)
  
  n <- length(snvs_for_pos)
  # Rellenar con NA si es necesario
  if (n < max_snvs) {
    snvs_for_pos <- c(snvs_for_pos, rep(NA, max_snvs - n))
  }
  
  mat_col <- matrix(snvs_for_pos, ncol = 1)
  colnames(mat_col) <- as.character(p)
  matrix_list[[as.character(p)]] <- mat_col
}

# Paso 3: Combinar matrices
mat <- do.call(cbind, matrix_list)  # Corregido "chind" a "cbind"


# Convertir NAs a 0 si prefieres
mat[is.na(mat)] <- 0


# Definir nueva escala de colores para datos transformados
col_fun <- colorRamp2(
  c(0, 2, 4, 6,8),
  c("#FFFFFF", "#FFCCCC", "#FF9999", "#FF6666", "#CC0000")
)

# Crear heatmap con transformación de raíz cuadrada
ht <- Heatmap(
  mat,
  na_col = "white",
  name = "avr",
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  col = col_fun,
  show_row_names = FALSE,
  show_column_names = TRUE,
  column_title = "Positional G>T in control data",
  row_title = "SNVs (1,414)",
  use_raster = FALSE,
  column_names_rot = 0,
  column_names_centered = TRUE,
  bottom_annotation = HeatmapAnnotation(
    "SNV Count" = anno_barplot(
      df_summary$total_snvs,
      bar_width = 0.8,
      gp = gpar(fill = "grey50"),
      annotation_name_rot = 0,
      height = unit(2, "cm")
    )
  )
)

draw(ht)
```
este análisis lo que estea haciendo es alg distinto a lo que tengo que hacer, en el sentido de que creo que es un análisis más enfocado en la parte de la posición que de la intensidad. 

```{r}
# ---- 1. Etiquetar top/bottom 100 (igual que antes) ----
top_ids <- df_avr %>% arrange(desc(avr)) %>% slice_head(n = 100) %>% pull(featureID)
bot_ids <- df_avr %>% arrange(avr)        %>% slice_head(n = 100) %>% pull(featureID)

df_avr <- df_avr %>%
  mutate(group = case_when(
    featureID %in% top_ids ~ "Frequent",
    featureID %in% bot_ids ~ "Rare",
    TRUE                   ~ "Other"
  ))
```

```{r}
# ---- 2. Fracción posicional por CONTEO de SNVs ----
pos_counts <- df_avr %>%
  filter(group %in% c("Frequent","Rare")) %>%
  count(group, pos, name = "n") %>%                     # cuántos SNVs en cada pos
  group_by(group) %>%
  mutate(pos_frac = n / sum(n)) %>%                     # fracción posicional
  ungroup()
```



```{r}
# ---- 3. Test de enriquecimiento por posición (Fisher) ----
totals <- pos_counts %>% group_by(group) %>% summarise(total = sum(n), .groups = "drop")

p_per_pos <- pos_counts %>%
  select(group, pos, n) %>%
  tidyr::pivot_wider(names_from = group, values_from = n, values_fill = 0) %>%
  rowwise() %>%
  mutate(
    p = {
      Freq_total <- totals$total[totals$group=="Frequent"]
      Rare_total <- totals$total[totals$group=="Rare"]
      fisher.test(
        matrix(c(Frequent,
                 Freq_total - Frequent,
                 Rare,
                 Rare_total - Rare), nrow = 2)
      )$p.value
    }
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p, method = "BH"))
```

```{r}
# ---- 4. Datos finales para graficar ----
plot_df <- pos_counts %>% left_join(p_per_pos, by = "pos")
sig_pts <- plot_df %>% filter(group=="Frequent", !is.na(p_adj), p_adj < 0.05)
```

```{r}
# ---- 5. Plot estilo paper ----
library(ggplot2)
seed_min <- 2; seed_max <- 6
ymax <- max(plot_df$pos_frac, na.rm = TRUE)
asterisk_off <- ymax * 0.03

ggplot() +
  # Rare: área gris + línea punteada
  geom_area(data = subset(plot_df, group=="Rare"),
            aes(pos, pos_frac), fill = "grey80", alpha = 0.9) +
  geom_line(data = subset(plot_df, group=="Rare"),
            aes(pos, pos_frac), colour = "grey30", linetype = "dashed", linewidth = 0.5) +
  # Frequent: barras rojas
  geom_col(data = subset(plot_df, group=="Frequent"),
           aes(pos, pos_frac), fill = "#FF4D4D", width = 0.8, alpha = 0.9) +
  # Caja región seed
  annotate("rect", xmin = seed_min - 0.5, xmax = seed_max + 0.5,
           ymin = -Inf, ymax = Inf, fill = "grey60", alpha = 0.08, colour = NA) +
  annotate("rect", xmin = seed_min - 0.5, xmax = seed_max + 0.5,
           ymin = 0, ymax = ymax, colour = "grey60", linetype = "dashed",
           fill = NA, linewidth = 0.4) +
  # Asteriscos
  geom_text(data = sig_pts,
            aes(pos, pos_frac + asterisk_off, label = "*"),
            colour = "red", size = 5, vjust = 0) +
  # Detalles estéticos
  geom_hline(yintercept = 0, colour = "black", linewidth = 0.6) +
  geom_rug(data = subset(plot_df, group=="Frequent"),
           aes(x = pos, y = 0), sides = "b", length = unit(2, "pt"), colour = "black") +
  scale_x_continuous(breaks = 1:22, expand = expansion(add = c(0.5,0.5))) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.12))) +
  labs(x = "Position:", y = "Positional fraction") +
  theme_classic(base_size = 12) +
  theme(axis.title.y = element_text(face = "bold"),
        axis.title.x = element_text(face = "bold", hjust = 0),
        axis.text    = element_text(colour = "black"),
        legend.position = "none") +
  annotate("text", x = 18,   y = ymax*1.08,
           label = "SNVs\nin miRNAs", fontface = "bold", size = 4) +
  annotate("text", x = 20.8, y = ymax*1.02,
           label = "Frequent", colour = "#FF4D4D", fontface = "bold", size = 3.6) +
  annotate("text", x = 20.8, y = ymax*0.96,
           label = "Rare", colour = "grey30",  fontface = "bold", size = 3.6)
```

```{r}

library(dplyr)
library(tidyr)
library(stringr)

# 1) Partimos de df_avr con featureID, pos y avr
df_seed <- df_avr %>%
  filter(pos %in% 2:6) %>%                     # solo region seed
  arrange(desc(avr)) %>%                       # orden descendente
  slice_head(n = min(200, nrow(.))) %>%        # top 200 SNVs en seed
  left_join(select(df_rpm_alex, featureID, clean_mut),
            by = "featureID") %>%
  separate(clean_mut,
           into = c("pos_str", "mut_raw"),
           sep  = "[_-]",
           remove = FALSE) %>%
  mutate(
    ref  = str_sub(mut_raw, 1, 1),             # primera letra
    alt  = str_sub(mut_raw, 2, 2),             # segunda letra
    mut  = paste0(ref, ">", alt),              # "C>T", "G>A", ...
    rank = row_number()                        # ranking por avr
  )

# 2) Creamos df_seed_G con solo los top 100 mutaciones que vienen de G
df_seed_G <- df_seed %>%
  filter(ref == "G") %>%
  slice_head(n = min(100, nrow(.)))
```

```{r}
library(ggplot2)
library(purrr)
library(patchwork)

# ---- Panel izquierdo: composición A/T/G/C en el top 200 de seed ----
cum_base <- map_dfr(seq_len(nrow(df_seed)), function(i) {
  ct <- table(factor(df_seed$ref[1:i],
                     levels = c("A","T","G","C")))
  tibble(
    rank = i,
    ref   = names(ct),
    frac  = as.numeric(ct) / sum(ct)
  )
})

p_base <- ggplot(cum_base, aes(rank, frac, color = ref)) +
  geom_line(size = 1) +
  scale_color_manual(values = c(
    A = "#1f77b4",  # azul
    T = "#d62728",  # rojo
    G = "#ff7f0e",  # naranja
    C = "#9467bd"   # morado
  )) +
  labs(
    x = "Rank",
    y = "Fraction",
    title = "SNVs in seed",
    subtitle = "Base types"
  ) +
  theme_minimal() +
  theme(legend.title = element_blank())

# ---- Panel derecho: composición G>T, G>C, G>A en el top 100 de G ----
cum_G <- map_dfr(seq_len(nrow(df_seed_G)), function(i) {
  ct <- table(factor(df_seed_G$mut[1:i],
                     levels = c("G>T","G>C","G>A")))
  tibble(
    rank = i,
    mut   = names(ct),
    frac  = as.numeric(ct) / sum(ct)
  )
})

p_G <- ggplot(cum_G, aes(rank, frac, color = mut)) +
  geom_line(size = 1) +
  scale_color_manual(values = c(
    "G>T" = "#d62728",  # rojo
    "G>C" = "#9467bd",  # morado
    "G>A" = "#1f77b4"   # azul
  )) +
  labs(
    x = "Rank",
    y = "Fraction",
    subtitle = "Variation types of G"
  ) +
  theme_minimal() +
  theme(legend.title = element_blank())

# ---- Unir ambos paneles ----
(p_base | p_G) + plot_layout(widths = c(2, 1))
```












```{r}
table(df_seed$ALT)
table(df_seed$REF)
head(df_seed$mut)
```
```{r}

library(dplyr)
library(stringr)
library(tidyr)

# 1) SNVs en seed con REF/ALT correctos y ranking por avr
df_seed <- df_alex_noPM %>%
  transmute(
    featureID = paste(`miRNA name`, str_replace(`pos:mut`, ":", "_"), sep = "_"),
    pos       = as.integer(str_extract(`pos:mut`, "^[0-9]+")),
    mut       = str_extract(`pos:mut`, "(?<=:)..$")        # "GT", "TA", etc
  ) %>%
  separate(mut, into = c("REF","ALT"), sep = 1, remove = FALSE) %>%
  left_join(df_avr, by = c("featureID","pos")) %>%
  filter(pos >= 2, pos <= 6) %>%
  arrange(desc(avr)) %>%
  mutate(rank = row_number())
```












```{r}
# indicadores por ALT
cum_bases <- df_seed %>%
  mutate(A = as.integer(ALT=="A"),
         T = as.integer(ALT=="T"),
         G = as.integer(ALT=="G"),
         C = as.integer(ALT=="C")) %>%
  select(rank, A:T) %>%
  mutate(across(A:C, cumsum)) %>%              # suma acumulada
  mutate(across(A:C, ~ .x / rank)) %>%         # divide entre el rank (1:k)
  pivot_longer(A:C, names_to="ALT", values_to="frac")
```













```{r}
# 1) Un SNV y una muestra al azar:
s <- snv_cols[1]
Cij <- df_alex_noPM[[s]][1]
Lj  <- Lj_vec[s]
rpm_test <- Cij / Lj * 1e6
Cij; Lj; rpm_test
```
```{r}
summary(rowSums(rpm_mat_alex))
```


```{r}
summary(Lj_vec)
```




```{r}
# Revisa el rango de tus valores
summary(df_ranked$avr)

# O mejor aún, revisa los cuantiles
quantile(df_ranked$avr, probs = seq(0, 1, 0.1), na.rm = TRUE)
```

```{r}
cat("Dimensiones de mat:", dim(mat), "\n")
cat("Número de posiciones:", nrow(df_summary), "\n")
```

```{r}
# Debería ser TRUE
all.equal(as.numeric(colnames(mat)), df_summary$pos)
```


```{r}
library(ComplexHeatmap)
library(circlize)


mat <- heat_wide %>%
  column_to_rownames("featureID") %>%
  as.matrix()

# Reordenar filas como definimos
mat <- mat[row_order, ]

# paleta roja de 0→5 (ajusta a tu escala real)
col_fun <- colorRamp2(c(0, 1.67, 3.33, 5), c("#FFFFFF", "#FFB3B3", "#FF6666", "#CC0000"))

ht <- Heatmap(mat,
              name = "avr",
              cluster_rows = FALSE,
              cluster_columns = FALSE,
              col = col_fun,
              show_row_names = FALSE,
              show_column_names = TRUE,
              column_title = "Position",
              row_title = "SNVs (ordered by avr within each position)",
              use_raster = FALSE)  

draw(ht)
```







```{r}
write.csv(
  df_alex,
  file      = "/Users/cesaresparza/New_Desktop/UCSD/8OG/alex_df.csv",
  row.names = TRUE
)
```


```{r}
write.csv(
  mat,
  file      = "/Users/cesaresparza/New_Desktop/UCSD/8OG/mat.csv",
  row.names = TRUE
)
```



de aquí vamos a la parte de usar los miRNAs de don Alex para este show  











```{r}
counts <- tibble::tibble(
  Category = c("Top 10%", "Expr filter", "Intersect"),
  n = c(length(top_10_miRNAs), length(all_three), length(intersect(top_10_miRNAs, all_three)))
)

ggplot(counts, aes(x = Category, y = n, fill = Category)) +
  geom_col() +
  geom_text(aes(label = n), vjust = -0.5) +
  labs(title = "miRNA Overlap Summary", y = "Number of miRNAs") +
  theme_minimal()
```














```{r}

pm_counts <- df_top_rpm %>%
  filter(`pos:mut` == "PM") %>%
  select(`miRNA name`, all_of(snv_cols)) %>%
  distinct()  # queda una fila por miRNA con sus WT‐reads en snv_cols

# 3) Extrae las lecturas totales (WT+SNV) por miRNA
tot_counts <- df_top_rpm %>%
  select(`miRNA name`, all_of(total_cols)) %>%
  distinct()  # queda una fila por miRNA con sus total_reads en total_cols

# 4) Junta ambos data.frames por miRNA
combined <- pm_counts %>%
  inner_join(tot_counts, by = "miRNA name")

# 5) Construye la tabla de % de mutación
pct_mat <- combined %>%
  transmute(`miRNA name`,
    !!!set_names(
      # para cada snv_col, calculamos (total - pm) / total *100
      lapply(snv_cols, function(s) {
        tot_col <- paste0(s, " (PM+1MM+2MM)")
        expr  <- (combined[[tot_col]] - combined[[s]]) / combined[[tot_col]] * 100
        # evita NaN si total==0:
        ifelse(combined[[tot_col]] > 0, expr, 0)
      }),
      # mantenemos el mismo nombre de columna para cada snv_col
      nm = snv_cols
    )
  )

# 6) Ya tienes pct_mat: filas = miRNA name, columnas = muestras (snv_cols),
#    y cada celda es el porcentaje de lecturas mutadas de ese miRNA en esa muestra,
#    sin renombrar nada.

# Si quieres, lo puedes ordenar por % medio de mutación:
pct_ranked <- pct_mat %>%
  rowwise() %>%
  mutate(mean_pct = mean(c_across(-`miRNA name`), na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(desc(mean_pct))
```

```{r}
miRNA_100_counts <- pct_mat %>%
  rowwise() %>%
  mutate(n100 = sum(c_across(-`miRNA name`) == 100, na.rm = TRUE)) %>%
  ungroup() %>%
  select(`miRNA name`, n100) %>%
  filter(n100 > 0)      # sólo los miRNAs con al menos un 100 %

# vector de miRNAs con al menos un caso al 100 %
miRNAs_with_100 <- miRNA_100_counts$`miRNA name`

# 2) Cuenta por muestra cuántos miRNAs llegan a 100 %
sample_100_counts <- pct_mat %>%
  select(-`miRNA name`) %>%
  summarise(across(everything(), ~ sum(.x == 100, na.rm = TRUE))) %>%
  pivot_longer(everything(),
               names_to  = "sample",
               values_to = "n100_samples") %>%
  filter(n100_samples > 0)

# 3) Agrega esas cuentas por grupo
groups_df <- sample_info(sample_100_counts$sample)

sample_100_by_group <- sample_100_counts %>%
  left_join(groups_df, by = "sample") %>%
  group_by(group) %>%
  summarise(
    total_samples_with_100 = n(),         # cuántas muestras tienen al menos un miRNA al 100%
    total_100_events       = sum(n100_samples)  # suma de todos los casos 100 % en esas muestras
  )

# —— RESULTADOS —— 

# a) miRNA_100_counts: qué miRNAs tienen al menos un sample al 100 % y cuántos
print(miRNA_100_counts)

# b) sample_100_counts: en qué muestras aparecen eventos 100 % y cuántos
print(sample_100_counts)

# c) sample_100_by_group: resumen por grupo de muestras
print(sample_100_by_group)

# d) vector de miRNAs de interés
print(miRNAs_with_100)
```

```{r}
# 1) Ordena y numera para eje x
miRNA_100_trend <- miRNA_100_counts %>%
  arrange(n100) %>% 
  mutate(idx = row_number())

# 2) Gráfico de línea + puntos
ggplot(miRNA_100_trend, aes(x = idx, y = n100)) +
  geom_line(color = "steelblue", linewidth = 0.8) +
  geom_point(color = "steelblue", size = 1) +
  theme_minimal() +
  theme(
    axis.text.x  = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  labs(
    x     = "miRNAs (ordered by number of 100% samples)",
    y     = "number of 100% mutated samples",
    title = "100% mutation events distribution"
  )

# 2) Histogram: distribución de casos 100% por muestra
#    Primero ponemos el group
sample_100_plot <- sample_100_counts %>%
  left_join(groups_df, by = "sample")

ggplot(sample_100_plot, aes(
      x = n100_samples, 
      fill = group
    )) +
  geom_histogram(binwidth = 1, position = "dodge", color = "white") +
  labs(
    x     = "Number of miRNAs at 100% mutation",
    y     = "Count of samples",
    title = "Distribution of 100% mutation events per sample",
    fill  = "Group"
  ) +
  theme_minimal()
```



```{r}

binned <- miRNA_100_counts %>%
  filter(n100 > 0) %>%  
  mutate(
    bin = cut(
      n100,
      breaks = c(0, 10, 50, 100, 250, 416),
      labels = c("1–10", "11–50", "51–100", "101–250", "251–416"),
      right  = TRUE
    )
  )

bin_counts <- binned %>%
  count(bin) %>%
  arrange(factor(bin, levels = c("1–10","11–50","51–100","101–250","251–416")))

# 3) Barplot simple
ggplot(bin_counts, aes(x = bin, y = n)) +
  geom_col(fill = "steelblue") +
  labs(
    x     = "Prevalence bin (# samples at 100% mutated)",
    y     = "Number of miRNAs",
    title = "Distribution of miRNAs by 100%-mutation Prevalence"
  ) +
  theme_minimal()


miRNAs_90plus <- miRNA_100_counts %>%
  filter(n100 >= 90) %>%
  pull(`miRNA name`)


miRNAs_90plus

```



```{r}
split_df_top_rpm <- split_mutations(df_top_rpm, mut_col = "pos:mut")
collapsed_df_top_rpm <- collapse_after_split(split_df_top_rpm)
```


```{r}
df_gt_only <- filter_GtoT(collapsed_df_top_rpm)

```


```{r}
library(dplyr)
library(stringr)

# 0) Emparejar cada snv_col con su total_col
tot_map <- setNames(total_cols, snv_cols)

# 1) Creamos un mapa para emparejar cada snv_col con su total_col
tot_map <- setNames(total_cols, snv_cols)

# 2) Partimos de df_gt_only y añadimos featureID
pct_gt_top <- df_gt_only %>%
  rename(miRNA_name = `miRNA name`) %>%            # quito espacios
  mutate(
    clean_mut = str_replace(`pos:mut`, ":", "_"),  # "4:GT" → "4_GT"
    featureID = paste(miRNA_name, clean_mut, sep = "_")
  )

# 3) Para cada muestra en snv_cols, calculamos:
#    %G>T = SNV_reads / total_reads * 100
for(s in snv_cols) {
  tot_col <- tot_map[[s]]
  
  # vector vacío
  pct_vec <- numeric(nrow(pct_gt_top))
  
  # dónde total_reads > 0
  ok <- pct_gt_top[[tot_col]] > 0
  
  # sólo en esas posiciones calculamos la fracción
  pct_vec[ok] <- pct_gt_top[[s]][ok] / pct_gt_top[[tot_col]][ok] * 100
  
  # asignamos de vuelta
  pct_gt_top[[s]] <- pct_vec
}

# 4) Eliminamos las columnas de totales y dejamos featureID + snv_cols
pct_gt_top <- pct_gt_top %>%
  select(featureID, all_of(snv_cols))

# Comprueba
dim(pct_gt_top)    # filas = #SNV-features, cols = 1 + length(snv_cols)
head(pct_gt_top)
```




```{r}
# 1) Capa valores extremos >2 → 0
#    (mat_exp tiene filas = SNV-features, cols = muestras, valores = %G>T)
mat_gt <- pct_gt_top %>%
  tibble::column_to_rownames("featureID") %>%
  as.matrix()

mat_filt <- mat_gt
mat_filt[mat_filt > 2] <- 0

```


```{r}
library(ComplexHeatmap)
library(dendextend)
library(dynamicTreeCut)
library(circlize)
library(RColorBrewer)


# 2) Lee la matriz (ajusta la ruta si hace falta)
snv_mat <- mat_filt

# 3) Calcula dendrogramas
row_hc   <- hclust(dist(snv_mat))
col_hc   <- hclust(dist(t(snv_mat)))
row_dend <- as.dendrogram(row_hc)
col_dend <- as.dendrogram(col_hc)

# 4) Detecta clusters automáticamente (sin especificar k fijo)
row_clust <- cutreeDynamic(dendro = row_dend, minClusterSize = 5)
col_clust <- cutreeDynamic(dendro = col_dend, minClusterSize = 5)

# 5) Genera paleta rojo-blanco
col_fun <- colorRamp2(c(0, 2), c("white", "red"))

# 6) Colores distintos para cada cluster
nmax <- max(c(row_clust, col_clust))
cols_clusters <- brewer.pal(n = min(nmax, 12), name = "Set3")
cluster_cols  <- setNames(cols_clusters[1:nmax], seq_len(nmax))

# 7) Anotación de bloques para filas y columnas
ha_left <- rowAnnotation(
  Cluster = anno_block(
    gp     = gpar(fill = cluster_cols[row_clust]),
    labels = paste0("R", row_clust),
    labels_gp = gpar(col = "white", fontsize = 8)
  )
)
ha_top <- HeatmapAnnotation(
  Cluster = anno_block(
    gp     = gpar(fill = cluster_cols[col_clust]),
    labels = paste0("C", col_clust),
    labels_gp = gpar(col = "white", fontsize = 8)
  )
)

# 8) Dibuja el heatmap con dendrogramas en ambos ejes y sombreado de clusters
Heatmap(
  snv_mat,
  name              = "% SNV",
  col               = col_fun,
  # nutre los dendrogramas calculados
  cluster_rows      = row_dend,      # acepta un objeto dendrogram  [oai_citation:0‡jokergoo.github.io](https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html?utm_source=chatgpt.com)
  cluster_columns   = col_dend,
  # fragmenta en tantos slices como clusters detectados
  row_split         = row_clust,
  column_split      = col_clust,
  # añade los bloques de color
  left_annotation   = ha_left,
  top_annotation    = ha_top,
  # ajustes de visualización
  show_row_names    = FALSE,
  show_column_names = FALSE,
  heatmap_legend_param = list(
    title_gp  = gpar(fontsize = 10),
    labels_gp = gpar(fontsize = 8)
  )
)
```

```{r}
write.csv(
  mat_gt,
  file      = "/Users/cesaresparza/New_Desktop/UCSD/8OG/mat_gt.csv",
  row.names = TRUE
)
```






Forma de Alex para sacar los top miRNAs tomando las cuentas crudas de SNVs-GT po

```{r}

# 1) Expandir mutaciones separadas por coma
df_split <- split_mutations(df)

# 2) Colapsar nuevamente sumando SNVs y dejando totales intactos
df_collapsed <- collapse_after_split(df_split)

# 3) Filtrar solo GT
df_gt <- filter_GtoT(df_collapsed)
```

```{r}
# Para cada miRNA, sumar los SNV (GT) por muestra
df_gt_snv_con <- df_gt %>%
  group_by(`miRNA name`) %>%
  summarise(
    # Sumamos las cuentas de SNVs por muestra
    across(all_of(snv_cols), ~ sum(.x, na.rm = TRUE)),
    # Tomamos un único valor del total por muestra (es constante para un miRNA)
    across(all_of(total_cols), ~ first(.x)),
    .groups = "drop"
  )
```

```{r}
df_gt_snv_con <- df_gt_snv_con %>%
  mutate(total_GT_reads = rowSums(across(all_of(snv_cols)), na.rm = TRUE))

df_gt_ranked <- df_gt_snv_con %>%
  arrange(desc(total_GT_reads))
```

```{r}
# Número de miRNAs que corresponden al 10%
n_top <- ceiling(0.10 * nrow(df_gt_ranked))

# Extraer los nombres de miRNAs del top 10%
top_10_miRNAs <- df_gt_ranked %>%
  slice_head(n = n_top) %>%
  pull(`miRNA name`)
```



Opción de Chat que tiene normalización por RPM 
```{r}
# (A) Totales por miRNA x muestra y tamaños de librería (para RPM)
totals_wide <- df_collapsed %>%
  select(miRNA = `miRNA name`, all_of(total_cols)) %>%
  distinct()                               # 1 fila por miRNA
```

```{r}
# librería por muestra
libsize <- colSums(totals_wide[total_cols], na.rm = TRUE)

# (B) Filtro de expresión en RPM (ejemplo: RPM>=100 en >=50% muestras)
totals_rpm <- as.data.frame(sweep(as.matrix(totals_wide[total_cols]), 2, libsize, `/`) * 1e6)
keep_miRNAs <- totals_wide %>%
  mutate(prop_rpm_ge = rowMeans(totals_rpm >= 90, na.rm = TRUE)) %>%
  filter(prop_rpm_ge >= 0.5) %>%           # ajusta a tu gusto
  pull(miRNA)

# (C) Sumar G>T por miRNA x muestra (como ya hacías)
gt_sum <- df_gt %>%
  filter(`miRNA name` %in% keep_miRNAs) %>%
  group_by(miRNA = `miRNA name`) %>%
  summarise(across(all_of(snv_cols), ~ sum(.x, na.rm = TRUE)), .groups = "drop")

# (D) Pasar esas cuentas G>T a RPM (SNV-RPM G>T)
gt_rpm <- as.data.frame(sweep(as.matrix(gt_sum[snv_cols]), 2, libsize, `/`) * 1e6)

# (E) Score de abundancia por miRNA: suma de SNV-RPM a través de muestras
gt_rpm_sum <- rowSums(gt_rpm, na.rm = TRUE)

df_gt_ranked <- tibble(miRNA = gt_sum$miRNA,
                       gt_rpm_sum = gt_rpm_sum) %>%
  arrange(desc(gt_rpm_sum))


top_10_miRNAs <- df_gt_ranked %>% pull(miRNA)
```

Aquí comenzamos con el nuevo top miRNAs











































































```{r}
# Umbrales recomendados (ajústalos)
min_total  <- 500L      # cobertura mínima del miRNA por muestra
rpm_gate   <- 1.0       # RPM_total mínimo para considerar "expresado"
prev_gate  <- 0.20      # % mínimo de muestras con expresión (20%)
vaf_min    <- 0.005     # 0.5%: umbral de VAF para "detección" de SNV


library(dplyr)
library(tidyr)
library(stringr)

clean_sample <- function(x) str_remove(x, fixed(" (PM+1MM+2MM)"))

# 1) Tamaño de librería por muestra (R_p): suma de totales de miRNA
libsize_tbl <- tibble(
  sample = clean_sample(total_cols),
  R_p    = colSums(totals_wide[total_cols], na.rm = TRUE)
)

# 2) Totales del miRNA por muestra → RPM_total por miRNA
miRNA_totals_long <- totals_wide %>%
  select(`miRNA name`, all_of(total_cols)) %>%
  pivot_longer(cols = all_of(total_cols),
               names_to = "sample_total", values_to = "miRNA_total") %>%
  mutate(sample = clean_sample(sample_total)) %>%
  left_join(libsize_tbl, by = "sample") %>%
  mutate(RPM_total = if_else(!is.na(R_p) & R_p > 0, 1e6 * (miRNA_total / R_p), NA_real_))

# 3) Gate: miRNAs suficientemente expresados (mediana + prevalencia de expresión)
miRNA_gate <- miRNA_totals_long %>%
  group_by(`miRNA name`) %>%
  summarise(
    median_RPM_total = median(RPM_total, na.rm = TRUE),
    prev_expr = mean(!is.na(RPM_total) & RPM_total >= rpm_gate & miRNA_total >= min_total, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(median_RPM_total >= rpm_gate, prev_expr >= prev_gate) %>%
  pull(`miRNA name`)



# Columnas de SNV (cuentas) en df_gt (ya filtrado a G>T)
snv_cols <- setdiff(colnames(df_gt), c("miRNA name", "pos:mut"))

# Llevamos SNV a formato largo y unimos libsize + totales del miRNA
snv_long <- df_gt %>%
  mutate(featureID = paste(`miRNA name`, str_replace(`pos:mut`, ":", "_"), sep = "_")) %>%
  pivot_longer(cols = all_of(snv_cols), names_to = "sample", values_to = "snv_reads") %>%
  left_join(libsize_tbl, by = "sample") %>%
  left_join(
    miRNA_totals_long %>% select(`miRNA name`, sample, miRNA_total),
    by = c("miRNA name", "sample")
  ) %>%
  mutate(
    RPM = if_else(!is.na(R_p) & R_p > 0, 1e6 * (snv_reads / R_p), NA_real_),
    VAF = if_else(!is.na(miRNA_total) & miRNA_total > 0, snv_reads / miRNA_total, NA_real_),
    detected = !is.na(VAF) & (VAF >= vaf_min) & (miRNA_total >= min_total)
  )

df_snv_ranked <- snv_long %>%
  # Quedarnos solo con miRNAs que pasaron el gate de expresión
  filter(`miRNA name` %in% miRNA_gate) %>%
  group_by(featureID, `miRNA name`, `pos:mut`) %>%
  summarise(
    mean_all_RPM      = mean(replace_na(RPM, 0), na.rm = TRUE),                  # promedio en todas (undetected = 0)
    prevalence        = mean(replace_na(detected, FALSE), na.rm = TRUE),         # % de muestras detectadas
    median_detected_RPM = if (sum(replace_na(detected, FALSE)) > 0)
                            median(RPM[detected], na.rm = TRUE) else NA_real_,
    .groups = "drop"
  ) %>%
  mutate(
    # Score primario para ranking (elige el que prefieras):
    score = mean_all_RPM
    # Alternativa bicriterio:
    # score = prevalence * coalesce(median_detected_RPM, 0)
  ) %>%
  arrange(desc(score)) %>%
  mutate(rank = row_number())


miRNA_expression_rank <- miRNA_totals_long %>%
  group_by(`miRNA name`) %>%
  summarise(
    median_RPM_total = median(RPM_total, na.rm = TRUE),
    prev_expr        = mean(!is.na(RPM_total) & RPM_total >= rpm_gate & miRNA_total >= min_total, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(median_RPM_total))

```



























Esta es la función para la parte de representar de distintas formas los valores de los NaNs

```{r}
impute_snv_missing <- function(df, snv_cols,
                               method = c("row_percentile","row_median","row_mean","zero"),
                               q = 0.10,
                               fallback = 0,
                               return_mask = FALSE) {
  method <- match.arg(method)

  # Construye matriz numérica con solo las columnas de SNV
  snv_df <- df[snv_cols]
  snv_mat <- as.matrix(data.frame(lapply(snv_df, function(x) as.numeric(x)),
                                  check.names = FALSE))

  # Faltantes: NA o NaN
  bad <- is.na(snv_mat) | is.nan(snv_mat)

  # Funciones auxiliares por fila
  row_stat <- switch(
    method,
    "zero" = NULL,
    "row_mean" = function(v) { m <- mean(v, na.rm = TRUE); if (!is.finite(m)) fallback else m },
    "row_median" = function(v) { m <- stats::median(v, na.rm = TRUE); if (!is.finite(m)) fallback else m },
    "row_percentile" = function(v) {
      m <- stats::quantile(v, probs = q, na.rm = TRUE, names = FALSE, type = 7)
      if (!is.finite(m)) fallback else m
    }
  )

  if (method == "zero") {
    fill_vals <- matrix(0, nrow = nrow(snv_mat), ncol = ncol(snv_mat))
  } else {
    # calcula el estadístico por fila y expándelo al ancho de la matriz
    rs <- apply(snv_mat, 1, row_stat)
    fill_vals <- matrix(rep(rs, times = ncol(snv_mat)), nrow = nrow(snv_mat))
  }

  # Imputa solo donde hay NA/NaN
  snv_mat[bad] <- fill_vals[bad]

  out <- df
  out[snv_cols] <- snv_mat

  if (return_mask) {
    return(list(data = out, imputed_mask = bad))
  } else {
    return(out)
  }
}
```


Esta es la función para pasar a NaN los menores a 50 

```{r}
# Marca NaN en df_counts (cuentas) donde df_pct (porcentajes) > threshold.
mask_counts_with_pct <- function(df_counts, df_pct, snv_cols, threshold = 50, use_NaN = TRUE) {
  out <- df_counts
  # aplicar SOLO en filas SNV (no PM)
  snv_rows <- df_pct[["pos:mut"]] != "PM"

  for (c in snv_cols) {
    if (!c %in% names(df_pct) || !c %in% names(out)) next
    v_pct <- suppressWarnings(as.numeric(df_pct[[c]]))
    m <- snv_rows & is.finite(v_pct) & (v_pct > threshold)
    out[[c]][m] <- if (use_NaN) NaN else NA_real_
  }
  out
}
```



Esta es la función que tengo para pasar a porcentajes 

```{r}
counts_to_percent <- function(df, total_cols, snv_cols,
                              scale = 100, convert_pm_row = FALSE) {
  out <- df
  snv_rows <- if (convert_pm_row) rep(TRUE, nrow(df)) else df[["pos:mut"]] != "PM"

  for (c in snv_cols) {
    tcol <- paste0(c, " (PM+1MM+2MM)")
    if (!tcol %in% total_cols || !tcol %in% names(out)) next

    num <- as.numeric(out[[c]])
    den <- as.numeric(out[[tcol]])

    # % solo en filas SNV y si el denominador es válido; si no, NA
    val <- ifelse(snv_rows & is.finite(den) & den > 0, scale * (num / den),
                  ifelse(snv_rows, NA_real_, num))  # deja PM igual
    out[[c]] <- val
  }
  attr(out, "value_unit") <- ifelse(scale == 100, "percent", "fraction")
  out
}
```

AHORA VIENE LA NUEVA VERSION


```{r}
# === LIMPIEZA DE SNVs SOBRE-EXPRESADOS (simple y directa) ====================
drop_snv_overexpressed_simple <- function(df,
                                          total_cols,
                                          snv_cols,
                                          vaf_thr = 50,             # %VAF umbral
                                          min_samples_over_thr = 40,# ≥40 muestras
                                          min_total = 0,            # soporte mínimo (0 = ignorar)
                                          id_cols = c("miRNA name","pos:mut")) {
  # 1) %VAF con tu función (NO tocamos nada más)
  df_vaf <- counts_to_percent(df, total_cols, snv_cols, scale = 100, convert_pm_row = FALSE)

  # 2) Matrices numéricas (rápidas)
  pct_mat <- as.matrix(data.frame(lapply(df_vaf[snv_cols], as.numeric), check.names = FALSE))
  den_mat <- as.matrix(data.frame(lapply(df[paste0(snv_cols, " (PM+1MM+2MM)")], as.numeric), check.names = FALSE))

  # 3) Detectar filas SNV (excluir "PM" si existe)
  is_snv_row <- if ("pos:mut" %in% names(df)) df[["pos:mut"]] != "PM" else rep(TRUE, nrow(df))

  # 4) Celdas que cuentan como "sobre-expresadas"
  above <- (pct_mat >= vaf_thr)
  if (!is.null(min_total) && min_total > 0) {
    above <- above & (den_mat >= min_total)
  }
  above[!is_snv_row, ] <- FALSE

  # 5) Conteo por SNV y decisión
  n_over  <- rowSums(above, na.rm = TRUE)
  to_drop <- is_snv_row & (n_over >= min_samples_over_thr)

  # 6) ID legible del SNV (miRNA_pos_mut con “:” → “_”)
  feature_id <- if (all(id_cols %in% names(df))) {
    paste(df[[id_cols[1]]], gsub(":", "_", df[[id_cols[2]]]), sep = "_")
  } else rownames(df)

  dropped <- feature_id[to_drop]

  # 7) Salidas
  list(
    df_vaf_clean = df_vaf[!to_drop, , drop = FALSE], # %VAF limpio (wide)
    dropped_snvs = dropped
  )
}
```

```{r}
clean_res <- drop_snv_overexpressed_simple(
  df         = df,            # tu df original (cuentas)
  total_cols = total_cols,    # columnas "... (PM+1MM+2MM)"
  snv_cols   = snv_cols,      # columnas de SNV por muestra
  vaf_thr    = 50,            # ≥50%
  min_samples_over_thr = 40,  # en ≥40 muestras
  min_total  = 500            # opcional (p.ej. exige ≥100 lecturas del miRNA)
)

df_vaf_clean   <- clean_res$df_vaf_clean
snvs_eliminados <- clean_res$dropped_snvs
length(snvs_eliminados)
```

```{r}
top_miRNAs_by_total <- function(df, total_cols, top_frac = 0.10) {
  # Escoger una fila por miRNA para leer los totales (preferimos "PM" si existe)
  if (all(c("miRNA name","pos:mut") %in% names(df))) {
    rep_rows <- df |>
      dplyr::group_by(`miRNA name`) |>
      dplyr::arrange(dplyr::desc(`pos:mut` == "PM"), .by_group = TRUE) |>
      dplyr::slice(1) |>
      dplyr::ungroup()
  } else {
    rep_rows <- df |>
      dplyr::group_by(`miRNA name`) |>
      dplyr::slice(1) |>
      dplyr::ungroup()
  }

  # Sumar totales por miRNA a través de todas las muestras
  tot_mat <- as.matrix(data.frame(lapply(rep_rows[total_cols], as.numeric), check.names = FALSE))
  mi_sum  <- rowSums(tot_mat, na.rm = TRUE)

  ranking <- dplyr::tibble(`miRNA name` = rep_rows$`miRNA name`, total_sum = mi_sum) |>
    dplyr::arrange(dplyr::desc(total_sum))

  n_top <- max(1, ceiling(top_frac * nrow(ranking)))
  top_names <- ranking |>
    dplyr::slice_head(n = n_top) |>
    dplyr::pull(`miRNA name`)

  list(top_names = top_names, ranking = ranking)
}
```

```{r}
top_res <- top_miRNAs_by_total(df, total_cols, top_frac = 0.10)
top10_miRNAs <- top_res$top_names
length(top10_miRNAs); head(top10_miRNAs)
```

```{r}
# Filtra tu df por los miRNAs del top (panel expresado)
df_top <- df |> dplyr::filter(`miRNA name` %in% top10_miRNAs)

# Tus funciones tal cual:
df_split     <- split_mutations(df_top)
df_collapsed <- collapse_after_split(df_split)  # usa snv_cols y total_cols del entorno
df_gt        <- filter_GtoT(df_collapsed)

# (Opcional) calcula %VAF sobre df_gt si quieres matrices por SNV/miRNA:
df_gt_pct <- counts_to_percent(df_gt, total_cols, snv_cols, scale = 100, convert_pm_row = FALSE)
```






mi biblia para cómo usar lo de las opciones de los NaNs

```{r}
# 1) Marcar >50% como faltantes :
df_nan <- replace_above_50(df_pct, snv_cols)  # df_pct ya con % en SNVs

# 2a) Imputar con percentil 10% por fila (conservador; recomendado para no inflar):
df_imp_p10 <- impute_snv_missing(df_nan, snv_cols, method = "row_percentile", q = 0.10)

# 2b) Imputar con mediana por fila (robusto; útil en resúmenes de grupo):
df_imp_med <- impute_snv_missing(df_nan, snv_cols, method = "row_median")

# 2c) Imputar con ceros (útil solo si alguna librería exige matriz completa, p.ej. PCA agresivo):
df_imp_zero <- impute_snv_missing(df_nan, snv_cols, method = "zero")
```


```{r}
df_pct <- counts_to_percent(df, total_cols, snv_cols)
```

```{r}
df_counts_masked <- mask_counts_with_pct(df, df_pct, snv_cols)
```


```{r}
# 2a) Imputar con percentil 20% por fila (conservador; recomendado para no inflar):
df_imp_p20 <- impute_snv_missing(df_counts_masked, snv_cols, method = "row_percentile", q = 0.20)
```


aquí ya usamos el df limpio 

```{r}

# 1) Expandir mutaciones separadas por coma
df_split <- split_mutations(df)

# 2) Colapsar nuevamente sumando SNVs y dejando totales intactos
df_collapsed <- collapse_after_split(df_split)

# 3) Filtrar solo GT
df_gt <- filter_GtoT(df_collapsed)
```


DE AQUI HACEMOS LO DE LOS TOP MIRNAS

```{r}
# --- CHUNK 1: SNV-level RPM_sum y rank ----------------------------
library(dplyr)
library(tidyr)
library(stringr)

# Función para limpiar el sufijo de totales y alinear nombres de muestra
clean_sample <- function(x) str_remove(x, fixed(" (PM+1MM+2MM)"))

# 1) Tamaño de librería por muestra (R_p): suma de totales de miRNA
libsize_tbl <- tibble(
  sample = clean_sample(total_cols),
  R_p    = colSums(totals_wide[total_cols], na.rm = TRUE)
)

# 2) Columnas de conteos de SNV (todas las que no sean metadatos)
snv_cols <- setdiff(colnames(df_gt), c("miRNA name", "pos:mut"))

# 3) Pasar a largo, unir R_p y calcular RPM por SNV y muestra
snv_long <- df_gt %>%
  mutate(
    featureID = paste(`miRNA name`, str_replace(`pos:mut`, ":", "_"), sep = "_")
  ) %>%
  pivot_longer(
    cols = all_of(snv_cols),
    names_to = "sample",
    values_to = "snv_reads"
  ) %>%
  left_join(libsize_tbl, by = "sample") %>%
  mutate(
    RPM = if_else(!is.na(R_p) & R_p > 0, 1e6 * (snv_reads / R_p), NA_real_)
  )

# (Opcional) limitar a seed 2–6:
# snv_long <- snv_long %>%
#   mutate(pos = as.integer(str_extract(`pos:mut`, "^[0-9]+"))) %>%
#   filter(pos >= 2, pos <= 6)

# 4) Agregar por SNV a través de muestras → RPM_sum y rank
df_snv_ranked <- snv_long %>%
  group_by(featureID, `miRNA name`, `pos:mut`) %>%
  summarise(RPM_sum = sum(RPM, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(RPM_sum)) %>%
  mutate(rank = row_number())
```


```{r}
# --- CHUNK 2 (reemplazo): Top 10% de miRNAs por suma de RPM (G>T) ---

# miRNA_level viene de sumar RPM de todos los SNVs G>T de cada miRNA
miRNA_level <- snv_long %>%
  group_by(`miRNA name`) %>%
  summarise(RPM_sum = sum(RPM, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(RPM_sum))

## Opción A) Por conteo (ceil del 10% más altos)
N_total <- nrow(miRNA_level)
N_top   <- max(1, ceiling(0.10 * N_total))

top10pct_miRNAs <- miRNA_level %>%
  slice_head(n = N_top) %>%
  pull(`miRNA name`)

## Opción B) Por percentil (incluye empates en el 10%)
## (percent_rank: 0 = mínimo, 1 = máximo)
library(dplyr)
miRNA_level_pct <- miRNA_level %>%
  mutate(p_rank = percent_rank(RPM_sum))  # 1 = top absoluto

top10pct_miRNAs_ties <- miRNA_level_pct %>%
  filter(p_rank >= 0.90) %>%             # 90–100% = top 10%
  arrange(desc(RPM_sum)) %>%
  pull(`miRNA name`)
```



```{r}
# 1) Filtra tu df (ya GT) por los miRNAs del top
df_gt_top_top <- df_gt %>%
  dplyr::filter(`miRNA name` %in% top10pct_miRNAs_ties)
```






DE AQUI EMPEZAMOS CON LA PARTE DE LAS GRAFICAS YA QUE TENEMOS LOS TOP 

```{r}
# Patrones que quieres conservar
pat_keep_ALS <- "(ALS[-_]enrolment|ALS[-_]longitudinal)"
TOT_SUFFIX_REGEX <- "\\s*\\(PM\\+1MM\\+2MM\\)\\s*$"

## 1) Columnas SNV (cuentas de SNV)
keep_snv_cols_ALS <- snv_cols[str_detect(snv_cols, pat_keep_ALS)]
# (FIX 1) Asegura que aquí NO se cuele ninguna columna TOTAL con sufijo:
keep_snv_cols_ALS <- keep_snv_cols_ALS[!grepl(TOT_SUFFIX_REGEX, keep_snv_cols_ALS)]

## 2) Columnas TOTAL (PM+1MM+2MM)
# Primero quitamos el sufijo para poder detectar el mismo nombre de sample
base_tot_names <- str_replace(total_cols, TOT_SUFFIX_REGEX, "")
keep_total_cols_ALS <- total_cols[str_detect(base_tot_names, pat_keep_ALS)]

## 3) Subset del data frame original
df_collapsed_ALS <- df_gt %>%
  dplyr::select(dplyr::all_of(meta_cols),
                dplyr::all_of(keep_snv_cols_ALS),
                dplyr::all_of(keep_total_cols_ALS))
```



ahora vamos a hacer este pedo pero para la parte de los RPMs como estamos sacando acá



```{r}
# totales por muestra para cada miRNA (PM+1MM+2MM); una fila por miRNA
df_mirna_tot_ALS <- df_collapsed_ALS %>%
  dplyr::distinct(`miRNA name`, .keep_all = TRUE) %>%
  dplyr::select(`miRNA name`, dplyr::all_of(keep_total_cols_ALS))
```

```{r}
df_alex_noPM_ALS <- df_collapsed_ALS %>%
  dplyr::filter(`pos:mut` != "PM")
```



```{r}
Lj_vec_ALS <- df %>%
  dplyr::summarise(dplyr::across(dplyr::all_of(keep_total_cols_ALS), ~ sum(.x, na.rm = TRUE))) %>%
  unlist()
```

```{r}
# Nombra el vector de denominadores con NOMBRES BASE (sin sufijo)
names(Lj_vec_ALS) <- stringr::str_replace(names(Lj_vec_ALS), TOT_SUFFIX_REGEX, "")
```


```{r}
# (FIX 2) Chequeo en el MISMO dominio (base vs base)
missing_in_Lj_ALS <- setdiff(
  stringr::str_replace(keep_snv_cols_ALS, TOT_SUFFIX_REGEX, ""),
  names(Lj_vec_ALS)
)
if (length(missing_in_Lj_ALS))
  stop("Estas columnas no tienen denominador en Lj_vec: ",
       paste(missing_in_Lj_ALS, collapse = ", "))
```

```{r}
snv_mat_ALS      <- as.matrix(df_alex_noPM_ALS[keep_snv_cols_ALS])
denominators_ALS <- Lj_vec_ALS[keep_snv_cols_ALS]   # mismos nombres, mismo orden

rpm_mat_alex_ALS <- sweep(snv_mat_ALS, 2, denominators_ALS, "/") * 1e6
colnames(rpm_mat_alex_ALS) <- paste0(colnames(rpm_mat_alex_ALS), "_RPM")

df_rpm_alex_ALS <- bind_cols(df_alex_noPM_ALS[, meta_cols], as.data.frame(rpm_mat_alex_ALS))
```

```{r}
df_rpm_alex_ALS <- df_rpm_alex_ALS %>%
  rename(miRNA_name = `miRNA name`) %>%
  mutate(
    clean_mut = str_replace(`pos:mut`, ":", "_"),
    featureID = paste(miRNA_name, clean_mut, sep = "_"),
    pos = as.integer(str_extract(clean_mut, "^[0-9]+"))
  )
```


```{r}
rpm_cols_ALS <- grep("_RPM$", names(df_rpm_alex_ALS), value = TRUE)
```

```{r}
df_avr_ALS <- df_rpm_alex_ALS %>%
  mutate(avr_raw = rowMeans(across(all_of(rpm_cols_ALS)), na.rm = TRUE)) %>%
  filter(avr_raw > 0) %>%
  mutate(avr = log2(avr_raw + 1)) %>%
  select(featureID, miRNA_name, pos, avr)
```


```{r}
df_ranked_ALS <- df_avr_ALS %>%
  group_by(pos) %>%
  arrange(desc(avr), .by_group = TRUE) %>%
  mutate(order_within_pos = row_number()) %>%
  ungroup()
```



REPE 2
\

para el df de control, es lo mismo para el de ALS pero con el dataset de ALS 
```{r}
# -------- CONTROL (CTRL) --------
pat_keep_CTRL <- "(?i)control"
TOT_SUFFIX_REGEX <- "\\s*\\(PM\\+1MM\\+2MM\\)\\s*$"
strip_suffix <- function(x) stringr::str_replace(stringr::str_squish(x), TOT_SUFFIX_REGEX, "")

## 1) Columnas SNV (cuentas) y TOTAL derivadas del DF actual
# (re-derivamos desde df_gt para evitar contaminación)
total_cols <- grep(TOT_SUFFIX_REGEX, names(df_gt), value = TRUE)
snv_cols   <- setdiff(names(df_gt), c(meta_cols, total_cols))

# Filtra solo columnas de muestras CONTROL
keep_snv_cols   <- snv_cols[stringr::str_detect(snv_cols, pat_keep_CTRL)]
base_tot_names  <- strip_suffix(total_cols)
keep_total_cols <- total_cols[stringr::str_detect(base_tot_names, pat_keep_CTRL)]

# Subset del data frame original
df_collapsed <- df_gt %>%
  dplyr::select(dplyr::all_of(meta_cols),
                dplyr::all_of(keep_snv_cols),
                dplyr::all_of(keep_total_cols))
```



```{r}
# totales por muestra para cada miRNA (PM+1MM+2MM); una fila por miRNA
df_mirna_tot_alex <- df_collapsed %>%
  dplyr::distinct(`miRNA name`, .keep_all = TRUE) %>%   # evita duplicados por SNV
  dplyr::select(`miRNA name`, dplyr::all_of(keep_total_cols))
```

```{r}
# quita filas PM (perfect match) de las cuentas de SNV
df_alex_noPM <- df_collapsed %>%
  dplyr::filter(`pos:mut` != "PM")
```


```{r}
# vector de library size por muestra (CONTROL)
Lj_vec <- df  %>%
  dplyr::summarise(dplyr::across(dplyr::all_of(keep_total_cols), ~ sum(.x, na.rm = TRUE))) %>%
  unlist()

# nombra en dominio BASE (sin sufijo) para poder indexar con columnas SNV
names(Lj_vec) <- strip_suffix(names(Lj_vec))
```

```{r}
# Chequeo rápido de nombres (BASE vs BASE)
missing_in_Lj <- setdiff(strip_suffix(keep_snv_cols), names(Lj_vec))
if (length(missing_in_Lj))
  stop("Estas columnas no tienen denominador en Lj_vec (CTRL): ",
       paste(missing_in_Lj, collapse = ", "))
```

```{r}
snv_mat      <- as.matrix(df_alex_noPM[keep_snv_cols])
denominators <- Lj_vec[keep_snv_cols]   # mismos nombres, mismo orden

rpm_mat_alex <- sweep(snv_mat, 2, denominators, "/") * 1e6
colnames(rpm_mat_alex) <- paste0(colnames(rpm_mat_alex), "_RPM")

df_rpm_alex <- bind_cols(df_alex_noPM[, meta_cols], as.data.frame(rpm_mat_alex))
```

```{r}
df_rpm_alex <- df_rpm_alex %>%
  rename(miRNA_name = `miRNA name`) %>%
  mutate(
    clean_mut = str_replace(`pos:mut`, ":", "_"),
    featureID = paste(miRNA_name, clean_mut, sep = "_"),
    pos = as.integer(str_extract(clean_mut, "^[0-9]+"))
  )
```


```{r}
rpm_cols <- grep("_RPM$", names(df_rpm_alex), value = TRUE)
```

```{r}
df_avr <- df_rpm_alex %>%
  mutate(avr_raw = rowMeans(across(all_of(rpm_cols)), na.rm = TRUE)) %>%
  filter(avr_raw > 0) %>%
  mutate(avr = log2(avr_raw + 1)) %>%
  select(featureID, miRNA_name, pos, avr)
```


```{r}
df_ranked <- df_avr %>%
  group_by(pos) %>%
  arrange(desc(avr), .by_group = TRUE) %>%
  mutate(order_within_pos = row_number()) %>%
  ungroup()
```


gráfica de la parte de control contra ALS

```{r}
library(dplyr)

# 1) Contar por posición en cada grupo
pos_ctrl <- df_ranked %>%
  count(pos, name = "n_ctrl")

pos_als  <- df_ranked_ALS %>%
  count(pos, name = "n_als")

# 2) Totales globales
tot_ctrl <- sum(pos_ctrl$n_ctrl)
tot_als  <- sum(pos_als$n_als)

# 3) Unir y calcular fracciones
pos_df <- full_join(pos_ctrl, pos_als, by = "pos") %>%
  replace_na(list(n_ctrl = 0, n_als = 0)) %>%
  mutate(
    frac_ctrl = n_ctrl / tot_ctrl,
    frac_als  = n_als  / tot_als
  )

# 4) Test de Fisher para cada posición
pos_df <- pos_df %>%
  rowwise() %>%
  mutate(
    p = fisher.test(
      matrix(
        c(n_als,
          tot_als - n_als,
          n_ctrl,
          tot_ctrl - n_ctrl),
        nrow = 2
      )
    )$p.value
  ) %>%
  ungroup() %>%
  mutate(p_adj = p.adjust(p, method = "BH"))

# Resultado
pos_df
```

```{r}
# Preparamos formato largo
plot_df <- pos_df %>%
  select(pos, frac_ctrl, frac_als, p_adj) %>%
  pivot_longer(
    cols = c(frac_ctrl, frac_als),
    names_to  = "group",
    values_to = "fraction"
  ) %>%
  mutate(
    group = recode(group,
                   frac_ctrl = "Control",
                   frac_als  = "ALS")
  )

# Nivel máximo para la sombra
ymax <- max(plot_df$fraction) * 1.1

ggplot(plot_df, aes(x = pos, y = fraction, fill = group)) +
  # 1) Sombra de la región seed (pos 2–6)
  annotate(
    "rect",
    xmin = 2 - 0.5, xmax = 6 + 0.5,
    ymin = 0,       ymax = ymax,
    fill = "grey80", alpha = 0.3, inherit.aes = FALSE
  ) +
  # 2) Barras lado a lado
  geom_col(position = position_dodge(width = 0.8), width = 0.7) +
  # 3) Asteriscos solo donde p_adj < 0.05
  geom_text(
    data = filter(plot_df, group == "ALS" & p_adj < 0.05),
    aes(label = "*"),
    position = position_nudge(x = 0.2),
    vjust = -0.5, size = 5, color = "black"
  ) +
  scale_x_continuous(
    breaks = 1:23,
    minor_breaks = NULL
  ) +
  scale_fill_manual(values = c("Control" = "grey60", "ALS" = "#D62728")) +
  labs(
    x = "Position",
    y = "Positional fraction",
    fill = NULL,
    title = "comparing G>T distribution by position in ALS v.s. control",
    subtitle = "Control vs ALS (seed region shadowed, *p_adj<0.05)"
  ) +
  coord_cartesian(ylim = c(0, ymax)) +
  theme_classic(base_size = 14) +
  theme(
    axis.text.x  = element_text(size = 10),
    legend.position = c(0.8, 0.9)
  )
```





```{r}
process_vaf_matrix <- function(df, meta_cols, min_total = 500,
                               pat_ALS = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                               pat_CTRL = "(?i)control",
                               seed_pos = 2:7) {

  stopifnot(all(c("miRNA name","pos:mut") %in% names(df)))

  total_cols <- grep("\\(PM\\+1MM\\+2MM\\)$", names(df), value = TRUE)
  snv_cols   <- setdiff(names(df), c(meta_cols, total_cols))
  clean_sample <- function(x) stringr::str_remove(x, stringr::fixed(" (PM+1MM+2MM)"))

  # --- preparar filas y featureID (miRNA_pos:mut) y filtrar por seed ---
  df_proc <- df %>%
    dplyr::rename(miRNA_name = `miRNA name`) %>%
    dplyr::mutate(
      pos        = as.integer(stringr::str_extract(`pos:mut`, "^[0-9]+")),
      clean_mut  = stringr::str_replace(`pos:mut`, ":", "_"),
      featureID  = paste(miRNA_name, clean_mut, sep = "_")
    ) %>%
    dplyr::filter(pos %in% seed_pos)

  # --- numerador: lecturas del SNV por muestra ---
  snv_long <- df_proc %>%
    dplyr::select(featureID, miRNA_name, dplyr::all_of(snv_cols)) %>%
    tidyr::pivot_longer(
      cols = -c(featureID, miRNA_name),
      names_to = "sample", values_to = "snv_count"
    ) %>%
    dplyr::mutate(
      sample_clean = clean_sample(sample),
      snv_count    = suppressWarnings(as.numeric(snv_count))
    )

  # --- denominador: totales del miRNA por muestra (¡sin featureID!) ---
  tot_long <- df_proc %>%
    dplyr::select(miRNA_name, dplyr::all_of(total_cols)) %>%
    dplyr::distinct() %>%
    tidyr::pivot_longer(
      cols = -miRNA_name,
      names_to = "sample", values_to = "total_count"
    ) %>%
    dplyr::mutate(
      sample_clean = clean_sample(sample),
      total_count  = suppressWarnings(as.numeric(total_count))
    ) %>%
    # >>> FIX: hacer único por (miRNA_name, sample_clean)
    dplyr::group_by(miRNA_name, sample_clean) %>%
    dplyr::summarise(
      total_count = if (all(is.na(total_count))) NA_real_
                    else total_count[which.max(!is.na(total_count))],
      .groups = "drop"
    )

  # --- VAF = SNV / Total(miRNA) por muestra; NA si cobertura insuficiente ---
  df_vaf <- dplyr::left_join(
    snv_long, tot_long, by = c("miRNA_name","sample_clean")
  ) %>%
    dplyr::mutate(
      vaf = dplyr::if_else(is.finite(total_count) & total_count >= min_total,
                           snv_count/total_count, NA_real_),
      vaf = pmin(pmax(vaf, 0), 1)
    )

  # --- matriz wide para heatmap (NA = no evaluable); sin rellenar con 0 ---
  mat_vaf <- df_vaf %>%
    dplyr::select(featureID, sample_clean, vaf) %>%
    tidyr::pivot_wider(
      names_from = sample_clean, values_from = vaf,
      values_fill = NA_real_
    ) %>%
    tibble::column_to_rownames("featureID") %>%
    data.matrix()

  # eliminar SNVs sin ninguna muestra evaluable
  keep <- rowSums(is.finite(mat_vaf)) > 0
  mat_vaf <- mat_vaf[keep, , drop = FALSE]

  if (nrow(mat_vaf) == 0 || ncol(mat_vaf) == 0) {
    stop("❌ Empty matrix after filtering. No SNVs or samples passed thresholds.")
  }

  message("✅ Matrix: ", nrow(mat_vaf), " seed-SNVs; ", ncol(mat_vaf), " samples. ",
          "min_total=", min_total, ". NAs mean 'not enough coverage'.")

  list(matrix = mat_vaf, df_vaf = df_vaf,
       pat_ALS = pat_ALS, pat_CTRL = pat_CTRL)
}

```



```{r}
process_vaf_matrix <- function(df, meta_cols, min_total = 500,
                               pat_ALS = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                               pat_CTRL = "(?i)control") {
  
  total_cols <- grep("\\(PM\\+1MM\\+2MM\\)$", colnames(df), value = TRUE)
  snv_cols <- setdiff(colnames(df), c(meta_cols, total_cols))
  clean_sample <- function(x) str_remove(x, fixed(" (PM+1MM+2MM)"))
  
  df_proc <- df %>%
    rename(miRNA_name = `miRNA name`) %>%
    mutate(
      pos = as.numeric(str_extract(`pos:mut`, "^[0-9]+")),
      clean_mut = str_replace(`pos:mut`, ":", "_"),
      featureID = paste(miRNA_name, clean_mut, sep = "_")
    ) %>% filter(pos >= 2 & pos <= 7)

  snv_long <- df_proc %>%
    select(featureID, miRNA_name, all_of(snv_cols)) %>%
    pivot_longer(cols = -c(featureID, miRNA_name), names_to = "sample", values_to = "snv_count") %>%
    mutate(sample_clean = clean_sample(sample))

  tot_long <- df_proc %>%
    select(featureID, miRNA_name, all_of(total_cols)) %>%
    pivot_longer(cols = -c(featureID, miRNA_name), names_to = "sample", values_to = "total_count") %>%
    mutate(sample_clean = clean_sample(sample))

  df_vaf <- left_join(
    snv_long, tot_long,
    by = c("featureID", "miRNA_name", "sample_clean")
  ) %>%
    mutate(
      total_count = replace_na(total_count, 0),
      snv_count = replace_na(snv_count, 0),
      vaf = ifelse(total_count >= min_total, snv_count / total_count, 0),
      vaf = pmin(vaf, 1),
      vaf = replace_na(vaf, 0)
    )

  mat_vaf <- df_vaf %>%
    select(featureID, sample_clean, vaf) %>%
    pivot_wider(names_from = sample_clean, values_from = vaf, values_fill = 0) %>%
    column_to_rownames("featureID") %>%
    as.matrix()

  mat_vaf <- mat_vaf[rowMeans(mat_vaf) > 0, , drop = FALSE]

  if (nrow(mat_vaf) == 0 || ncol(mat_vaf) == 0) {
    stop("❌ Empty matrix after filtering. No SNVs or samples passed thresholds.")
  }

  message("✅ Matrix: ", nrow(mat_vaf), " GTs across seed regions in miRNAs: ALS V.S. control ", ncol(mat_vaf), " samples.")

  list(
    matrix = mat_vaf,
    df_vaf = df_vaf,
    pat_ALS = pat_ALS,
    pat_CTRL = pat_CTRL
  )
}
```

```{r}
plot_vaf_heatmap <- function(mat_vaf, zscore = TRUE,
                             pat_ALS = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                             pat_CTRL = "(?i)control") {
  
  if (zscore) {
    mat_scaled <- t(scale(t(mat_vaf)))
    mat_scaled[is.na(mat_scaled)] <- 0
    mat_plot <- mat_scaled
    title_label <- "VAF z-score ALS vs control"
    colormap <- colorRamp2(c(-2, 0, 2), c("#4575b4", "white", "#d73027"))
  } else {
    mat_plot <- mat_vaf * 100
    title_label <- "VAF proportion (%)"
    colormap <- colorRamp2(c(0, 0.75, 1.5), c("white", "#fcae91", "red"))
  }

  col_group <- case_when(
    str_detect(colnames(mat_plot), pat_ALS) ~ "ALS",
    str_detect(colnames(mat_plot), pat_CTRL) ~ "Control",
    TRUE ~ "Other"
  )

  col_ha <- HeatmapAnnotation(
    Group = col_group,
    col = list(Group = c("ALS" = "#D62728", "Control" = "grey60", "Other" = "grey90")),
    show_annotation_name = FALSE
  )

  ht <- Heatmap(
    mat_plot,
    name = title_label,
    col = colormap,
    top_annotation = col_ha,
    cluster_rows = TRUE,
    cluster_columns = TRUE,
    show_row_names = FALSE,
    show_column_names = FALSE,
    column_title = paste0(title_label, ": GTs ")
  )

  draw(ht, heatmap_legend_side = "right")
}
```



```{r}
# Construir matriz VAF (G>T ∩ seed 2:7, min_total=500)
pm <- process_vaf_matrix(
  df        = df_gt_top_top,
  meta_cols = c("miRNA name","pos:mut"),
)

# Heatmap de VAF crudo (%)
plot_vaf_heatmap(pm$matrix, zscore = FALSE,
                 pat_ALS = pm$pat_ALS, pat_CTRL = pm$pat_CTRL)

# Heatmap de VAF en z-score (por fila; NA→0 neutro)
plot_vaf_heatmap(pm$matrix, zscore = TRUE,
                 pat_ALS = pm$pat_ALS, pat_CTRL = pm$pat_CTRL)
```






aquí estoy con la parte de ver cuáles son los miRNAs con cuentas altas, o sea, en los top miRNAs busco como en cuántas muestras tienen expresión mayor a tal
```{r}
# --- CHUNK 1: lista de miRNAs (vector) -------------------------------
library(dplyr)

df_in <- df_gt_top_top   # <-- cámbialo si quieres usar otro df

miRNA_list <- df_in %>%
  distinct(`miRNA name`) %>%
  arrange(`miRNA name`) %>%
  pull(`miRNA name`)

miRNA_list
length(miRNA_list)  # cuántos miRNAs hay

```

```{r}
# --- CHUNK 2: matriz de totales por miRNA × muestra -------------------
library(dplyr)
library(tidyr)
library(stringr)
library(tibble)

df_in <- df_gt_top_top  # <-- mismo df que arriba
TOT_SUFFIX_REGEX <- "\\s*\\(PM\\+1MM\\+2MM\\)\\s*$"
clean_sample <- function(x) stringr::str_remove(x, stringr::fixed(" (PM+1MM+2MM)"))

# Columnas de totales (PM+1MM+2MM)
total_cols <- grep(TOT_SUFFIX_REGEX, names(df_in), value = TRUE)

# LARGO: un registro por (miRNA, muestra), con un solo total_count por par
tot_long <- df_in %>%
  rename(miRNA_name = `miRNA name`) %>%
  select(miRNA_name, all_of(total_cols)) %>%
  distinct() %>%                                  # evita duplicados por SNV
  pivot_longer(
    cols = -miRNA_name,
    names_to = "sample", values_to = "total_count"
  ) %>%
  mutate(
    sample_clean = clean_sample(sample),
    total_count  = suppressWarnings(as.numeric(total_count))
  ) %>%
  group_by(miRNA_name, sample_clean) %>%
  summarise(
    # si hay 2 filas para el mismo par, quédate con el no-NA (si existe)
    total_count = if (all(is.na(total_count))) NA_real_
                  else total_count[which.max(!is.na(total_count))],
    .groups = "drop"
  )

# WIDE: filas = miRNA, columnas = muestras (limpias)
miRNA_total_wide <- tot_long %>%
  pivot_wider(
    names_from  = sample_clean,
    values_from = total_count,
    values_fill = NA_real_
  ) %>%
  arrange(miRNA_name)

# Matriz numérica (sin la columna de nombre)
mat_miRNA_total <- miRNA_total_wide %>%
  column_to_rownames("miRNA_name") %>%
  as.matrix()

# Revisa tamaños
dim(miRNA_total_wide)  # filas = #miRNAs ; cols = 1 + #muestras
dim(mat_miRNA_total)   # filas = #miRNAs ; cols = #muestras
```


```{r}
# --- CHUNK 3: #muestras ≥ 500 por miRNA ------------------------------
min_total <- 200

miRNA_ge500 <- miRNA_total_wide %>%
  mutate(
    n_with_total = rowSums(across(-miRNA_name, ~ !is.na(.x))),           # con dato (incluye 0)
    n_ge500      = rowSums(across(-miRNA_name, ~ .x >= min_total), na.rm = TRUE),
    frac_ge500   = ifelse(n_with_total > 0, n_ge500 / n_with_total, NA_real_)
  ) %>%
  select(miRNA_name, n_ge500, n_with_total, frac_ge500) %>%
  arrange(desc(n_ge500))

miRNA_ge500 %>% print(n = 50)  # muestra las primeras 50 filas
```







```{r}
plot_vaf_heatmap <- function(mat_vaf, zscore = TRUE,
                             pat_ALS  = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                             pat_CTRL = "(?i)control",
                             # Etiquetado:
                             label_only_features = NULL,   # vector de IDs a forzar
                             label_top_n = NULL,           # p.ej. 40 → top 40 por promedio
                             label_rank_by = c("vaf_mean", "zpos_mean", "z_abs_mean"),
                             # Apariencia:
                             rowname_fontsize = 6,
                             legend_side = "right",
                             row_names_max_width_cm = 6,
                             return_df = FALSE) {

  label_rank_by <- match.arg(label_rank_by)

  ## 1) Matriz a graficar
  if (zscore) {
    mat_scaled <- t(scale(t(mat_vaf)))
    mat_scaled[is.na(mat_scaled)] <- 0      # NA de z -> neutro
    mat_plot <- mat_scaled
    title_label <- "VAF z-score ALS vs control: GTs"
    colormap <- circlize::colorRamp2(c(-2, 0, 2), c("#4575b4","white","#d73027"))
  } else {
    mat_plot <- mat_vaf * 100
    title_label <- "VAF proportion (%): GTs"
    colormap <- circlize::colorRamp2(c(0, 0.75, 1.5), c("white","#fcae91","red"))
  }

  ## 2) Grupo de columnas
  col_group <- dplyr::case_when(
    stringr::str_detect(colnames(mat_plot), pat_ALS)  ~ "ALS",
    stringr::str_detect(colnames(mat_plot), pat_CTRL) ~ "Control",
    TRUE ~ "Other"
  )
  col_ha <- ComplexHeatmap::HeatmapAnnotation(
    Group = col_group,
    col = list(Group = c("ALS"="#D62728","Control"="grey60","Other"="grey90")),
    show_annotation_name = FALSE
  )

  ## 3) Etiquetado opcional (top-N)
  show_row_names_flag <- TRUE
  right_ann <- NULL
  if (!is.null(label_only_features) || !is.null(label_top_n)) {
    show_row_names_flag <- FALSE
    if (is.null(label_only_features) && !is.null(label_top_n)) {
      scores <- switch(label_rank_by,
        vaf_mean   = rowMeans(mat_vaf, na.rm = TRUE),
        zpos_mean  = rowMeans(pmax(mat_plot, 0), na.rm = TRUE),
        z_abs_mean = rowMeans(abs(mat_plot), na.rm = TRUE)
      )
      label_only_features <- names(sort(scores, decreasing = TRUE))[seq_len(min(label_top_n, length(scores)))]
    }
    lab_set <- intersect(rownames(mat_plot), label_only_features)
    mark_at <- which(rownames(mat_plot) %in% lab_set)
    right_ann <- ComplexHeatmap::rowAnnotation(
      mark = ComplexHeatmap::anno_mark(
        at = mark_at,
        labels = rownames(mat_plot)[mark_at],
        side = "right",
        labels_gp = grid::gpar(fontsize = rowname_fontsize)
      )
    )
  }

  ## 4) Distancias robustas a NA (1 - correlación, pairwise)
  cor_dist_rows <- function(m) {
    if (nrow(m) < 2) return(stats::as.dist(matrix(0, 1, 1)))
    cm <- suppressWarnings(stats::cor(t(m), use = "pairwise.complete.obs"))
    cm[!is.finite(cm)] <- 0
    stats::as.dist(1 - cm)
  }
  cor_dist_cols <- function(m) {
    if (ncol(m) < 2) return(stats::as.dist(matrix(0, 1, 1)))
    cm <- suppressWarnings(stats::cor(m, use = "pairwise.complete.obs"))
    cm[!is.finite(cm)] <- 0
    stats::as.dist(1 - cm)
  }

  ## 5) Heatmap
  ht <- ComplexHeatmap::Heatmap(
    mat_plot, name = title_label, col = colormap, top_annotation = col_ha,
    cluster_rows    = nrow(mat_plot) > 1,
    cluster_columns = ncol(mat_plot) > 1,
    clustering_distance_rows    = cor_dist_rows,
    clustering_distance_columns = cor_dist_cols,
    show_row_names = show_row_names_flag,
    row_names_side = "right",
    row_names_gp = grid::gpar(fontsize = rowname_fontsize),
    row_names_max_width = grid::unit(row_names_max_width_cm, "cm"),
    show_column_names = FALSE,
    column_title = title_label,
    right_annotation = right_ann,
    na_col = "grey90"
  )

  ht_drawn <- ComplexHeatmap::draw(
    ht, heatmap_legend_side = legend_side, annotation_legend_side = legend_side
  )

  ## 6) Salidas opcionales en el orden del heatmap
  if (!return_df) return(invisible(ht_drawn))

  ro <- ComplexHeatmap::row_order(ht_drawn);  if (is.list(ro)) ro <- unlist(ro, use.names = FALSE)
  co <- ComplexHeatmap::column_order(ht_drawn); if (is.list(co)) co <- unlist(co, use.names = FALSE)
  row_order_names <- rownames(mat_plot)[ro]
  col_order_names <- colnames(mat_plot)[co]
  col_group_ord   <- col_group[co]

  mat_heatmap_ord <- mat_plot[row_order_names, col_order_names, drop = FALSE]
  mat_vaf_ord     <- mat_vaf [row_order_names, col_order_names, drop = FALSE]

  DF_heatmap <- data.frame(feature = row_order_names, mat_heatmap_ord, check.names = FALSE)
  DF_vaf     <- data.frame(feature = row_order_names, mat_vaf_ord,     check.names = FALSE)

  invisible(list(
    ht = ht_drawn,
    df_wide_heatmap = DF_heatmap,
    df_wide_vaf     = DF_vaf,
    row_order_names = row_order_names,
    column_order_names = col_order_names,
    col_group_ordered = col_group_ord
  ))
}

```


























```{r}
# Construir matriz VAF (G>T ∩ seed 2:7, min_total=500)
pm <- process_vaf_matrix(
  df        = df_gt_top_top,
  meta_cols = c("miRNA name","pos:mut"),
)

# Heatmap de VAF crudo (%)
plot_vaf_heatmap(pm$matrix, zscore = FALSE,
                 pat_ALS = pm$pat_ALS, pat_CTRL = pm$pat_CTRL)

# Heatmap de VAF en z-score (por fila; NA→0 neutro)
plot_vaf_heatmap(pm$matrix, zscore = TRUE,
                 pat_ALS = pm$pat_ALS, pat_CTRL = pm$pat_CTRL)
```

```{r}
# Distribución completa (y-escala en %)
p_full <- ggplot(dfv_eval, aes(group, 100*vaf, fill = group)) +
  geom_violin(trim = TRUE, alpha = 0.5) +
  geom_boxplot(width = 0.15, outlier.shape = NA) +
  labs(x = NULL, y = "VAF (%)", title = "VAF distribution (all evaluable cells)") +
  theme_bw() + theme(legend.position = "none")
p_full

# Zoom a 0–2% (que es donde suele vivir la mayor parte)
p_zoom <- p_full + coord_cartesian(ylim = c(0, 2)) +
  labs(title = "VAF distribution (zoom 0–2%)")
p_zoom

# Resumen numérico por grupo (cuantiles)
dfv_eval %>%
  group_by(group) %>%
  summarise(n = n(),
            q01 = quantile(vaf, 0.01, na.rm=TRUE),
            q25 = quantile(vaf, 0.25, na.rm=TRUE),
            med = median(vaf, na.rm=TRUE),
            q75 = quantile(vaf, 0.75, na.rm=TRUE),
            q99 = quantile(vaf, 0.99, na.rm=TRUE)) %>%
  mutate(dplyr::across(where(is.numeric), ~ . * 100))  # en %
```

```{r}
dfv_pos <- dfv_eval %>% filter(vaf > 0) %>% mutate(vaf_log10 = log10(vaf))
ggplot(dfv_pos, aes(group, vaf_log10, fill=group)) +
  geom_violin(alpha=0.5) + geom_boxplot(width=.15, outlier.shape = NA) +
  scale_y_continuous(
    breaks = log10(c(1e-4,1e-3,1e-2,1e-1)),
    labels = function(x) sprintf("%.3f%%", 100*10^x)
  ) +
  labs(x=NULL, y="VAF (log10 scale → %)", title="VAF>0 only") +
  theme_bw() + theme(legend.position = "none")
```



```{r}
thr_vec <- c(0.005, 0.01, 0.02, 0.05)  # 0.5%, 1%, 2%, 5%
pres_tab <- lapply(thr_vec, function(thr){
  dfv_eval %>%
    mutate(pos = vaf >= thr) %>%
    group_by(group) %>%
    summarise(frac_pos = mean(pos), n = n(), .groups="drop") %>%
    mutate(threshold = paste0(100*thr, "%"))
}) %>% bind_rows()

# Tabla de tasas (en %)
pres_tab %>% mutate(frac_pos = 100*frac_pos) %>% arrange(threshold, desc(group))
```
```{r}
thr <- 0.01  # 1%

# Conteos por SNV y grupo
by_snv <- dfv_eval %>%
  mutate(pos = vaf >= thr) %>%
  group_by(featureID, group) %>%
  summarise(n_pos = sum(pos), n_tot = n(), .groups="drop") %>%
  tidyr::pivot_wider(names_from = group, values_from = c(n_pos, n_tot), values_fill = 0)

# Fisher exact test (presencia)
fisher_res <- by_snv %>%
  rowwise() %>%
  mutate(
    p_fisher = {
      mat <- matrix(c(n_pos_ALS, n_tot_ALS - n_pos_ALS,
                      n_pos_Control, n_tot_Control - n_pos_Control), nrow = 2, byrow = TRUE)
      fisher.test(mat)$p.value
    }
  ) %>% ungroup() %>%
  mutate(p_adj = p.adjust(p_fisher, method = "BH")) %>%
  arrange(p_adj)

head(fisher_res, 15)  # SNVs con mayor diferencia de “presencia” (ALS vs Control)

# Diferencia de nivel entre positivos (Wilcoxon) por SNV
wilcoxon_res <- dfv_eval %>%
  filter(vaf >= thr) %>%
  group_by(featureID) %>%
  summarise(
    p_wilcox = tryCatch(
      wilcox.test(vaf[group=="ALS"], vaf[group=="Control"])$p.value,
      error = function(e) NA_real_
    ),
    n_ALS_pos     = sum(group=="ALS"),
    n_Control_pos = sum(group=="Control"),
    .groups="drop"
  ) %>%
  mutate(p_adj = p.adjust(p_wilcox, method = "BH")) %>%
  arrange(p_adj)

head(wilcoxon_res, 15)  # SNVs con mayor diferencia de “nivel” entre positivos
```


```{r}
dfv_eval_pos <- dfv_eval %>%
  mutate(pos = as.integer(stringr::str_extract(featureID, "_(\\d+)_") %>% gsub("_","",.))) %>%
  filter(!is.na(pos))

dfv_eval_pos %>%
  mutate(pos_hit = vaf >= thr) %>%
  group_by(group, pos) %>%
  summarise(frac = mean(pos_hit), .groups="drop") %>%
  ggplot(aes(pos, 100*frac, fill=group)) +
  geom_col(position="dodge") +
  labs(x="Position", y=sprintf("Fraction ≥ %.1f%%", 100*thr),
       title="Presence by position (≥ threshold)") +
  theme_bw()
```

```{r}
library(dplyr)
thr <- 0.01   # 1%
tab_pos <- vaf_long %>%
  mutate(evt = VAF >= thr) %>%
  count(group, pos, evt) %>%
  tidyr::pivot_wider(names_from = evt, values_from = n, values_fill = 0) %>%
  rowwise() %>%
  mutate(p = fisher.test(matrix(c(`TRUE`,`FALSE`), nrow=2, byrow=TRUE))$p.value) %>%
  ungroup() %>%
  group_by(pos) %>% summarise(p = first(p)) %>%
  mutate(p_adj = p.adjust(p, "BH"))
tab_pos
```









```{r}
sel <- c("hsa-let-7i-5p_4_GT","hsa-let-7a-5p_4_GT","hsa-let-7b-5p_2_GT")
plot_vaf_heatmap(
  vaf_result_seed$matrix, zscore=TRUE,
  pat_ALS=vaf_result_seed$pat_ALS, pat_CTRL=vaf_result_seed$pat_CTRL,
  label_only_features = sel,
  row_names_max_width_cm = 8, rowname_fontsize = 6
)
```

```{r}
library(stringr)

# Pega aquí tu lista tal cual (aunque tenga “−”):
snvs_user_raw <- c(
  "hsa−miR−1307−3p_5_GT","hsa−let−7i−5p_4_GT","hsa−miR−122−5p_2_GT","hsa−miR−24−3p_2_GT",
  "hsa−let−7f−5p_5_GT","hsa−miR−423−5p_2_GT","hsa−let−7a−5p_5_GT","hsa−let−7d−5p_4_GT",
  "hsa−let−7c−5p_4_GT","hsa−miR−744−5p_2_GT","hsa−let−7c−5p_2_GT","hsa−miR−126−3p_3_GT",
  "hsa−miR−223−3p_2_GT","hsa−miR−206_3_GT","hsa−let−7a−5p_2_GT","hsa−miR−328−3p_4_GT",
  "hsa−miR−24−3p_3_GT","hsa−miR−221−3p_2_GT","hsa−let−7d−5p_5_GT","hsa−miR−6134_7_GT",
  "hsa−miR−744−5p_5_GT","hsa−miR−25−3p_5_GT","hsa−let−7b−5p_4_GT","hsa−miR−101−3p_5_GT",
  "hsa−miR−148a−3p_4_GT","hsa−let−7a−5p_4_GT","hsa−miR−143−3p_2_GT","hsa−miR−191−5p_5_GT",
  "hsa−miR−744−5p_4_GT","hsa−miR−134−5p_4_GT","hsa−miR−6130_6_GT","hsa−miR−1−3p_2_GT",
  "hsa−miR−30d−5p_2_GT","hsa−miR−103a−3p_5_GT","hsa−miR−486−5p_5_GT","hsa−miR−93−5p_5_GT",
  "hsa−miR−92a−3p_5_GT","hsa−let−7i−5p_2_GT","hsa−miR−423−5p_5_GT","hsa−let−7f−5p_2_GT",
  "hsa−miR−103a−3p_2_GT","hsa−let−7b−5p_2_GT","hsa−miR−146a−5p_2_GT","hsa−miR−17−5p_5_GT",
  "hsa−miR−584−5p_5_GT","hsa−miR−134−5p_2_GT","hsa−miR−122−5p_3_GT","hsa−miR−206_2_GT",
  "hsa−let−7b−5p_5_GT","hsa−miR−423−3p_2_GT","hsa−miR−320a−3p_5_GT","hsa−miR−328−3p_3_GT",
  "hsa−miR−16−5p_3_GT","hsa−let−7f−5p_4_GT","hsa−miR−432−5p_5_GT","hsa−let−7i−5p_5_GT",
  "hsa−let−7d−5p_2_GT","hsa−miR−1−3p_3_GT","hsa−miR−3168_3_GT","hsa−miR−423−5p_4_GT"
)

# Normaliza guiones Unicode → "-"
normalize_id <- function(x) gsub("[\u2010\u2011\u2012\u2013\u2014\u2015\u2212]", "-", x, perl = TRUE)

user_norm <- normalize_id(snvs_user_raw)
rows_norm <- normalize_id(out$row_order_names)

pos <- match(user_norm, rows_norm)     # posición de cada SNV en el heatmap
found <- !is.na(pos)
pos_found <- sort(pos[found])

cat("SNVs en tu lista:", length(user_norm), "\n")
cat("Encontrados en el heatmap:", sum(found), "\n")
if (any(!found)) {
  cat("NO encontrados (muestra):\n"); print(head(snvs_user_raw[!found]))
}

# ¿forman un bloque contiguo?
is_contig <- length(pos_found) > 0 &&
             setequal(pos_found, seq.int(min(pos_found), max(pos_found)))
cat("\n¿Forman bloque contiguo? ", is_contig, "\n")
if (is_contig) {
  cat("Rango del bloque: filas", min(pos_found), "a", max(pos_found), "\n")
  cat("¿Empieza arriba del heatmap? ", min(pos_found) == 1, "\n")
}

# ¿tu lista coincide con las PRIMERAS K filas?
K <- length(pos_found)
topK <- rows_norm[seq_len(K)]
cat("\n¿Tu lista (encontrados) == top", K, "filas del heatmap?: ",
    identical(sort(user_norm[found]), sort(topK)), "\n")
```

```{r}
library(dplyr)

# usa sólo los que sí aparecieron y en el orden del heatmap:
snvs_block_in_order <- out$row_order_names[out$row_order_names %in% normalize_id(snvs_user_raw)]

df_block_heatmap <- out$df_wide_heatmap %>%
  semi_join(tibble::tibble(feature = snvs_block_in_order), by = "feature") %>%
  slice(match(snvs_block_in_order, feature))  # fuerza el MISMO orden

df_block_vaf <- out$df_wide_vaf %>%
  semi_join(tibble::tibble(feature = snvs_block_in_order), by = "feature") %>%
  slice(match(snvs_block_in_order, feature))
```


```{r}
library(dplyr)
library(stringr)
library(ComplexHeatmap)
library(circlize)
library(grid)

# Tu lista ordenada del bloque
snvs <- snvs_block_in_order  # si tu vector se llama distinto, ponlo aquí

# Subset en el mismo orden
snvs <- intersect(snvs, rownames(vaf_result_seed$matrix))
mat_vaf_block <- vaf_result_seed$matrix[snvs, , drop = FALSE]

# z-score por fila (igual que tu heatmap original)
mat_block <- t(scale(t(mat_vaf_block)))
mat_block[is.na(mat_block)] <- 0

# Anotación ALS/Control
pat_ALS  <- "(ALS[-_]enrolment|ALS[-_]longitudinal)"
pat_CTRL <- "(?i)control"
grp <- case_when(
  str_detect(colnames(mat_block), pat_ALS)  ~ "ALS",
  str_detect(colnames(mat_block), pat_CTRL) ~ "Control",
  TRUE ~ "Other"
)
ha <- HeatmapAnnotation(
  Group = grp,
  col = list(Group = c("ALS"="#D62728","Control"="grey60","Other"="grey90")),
  show_annotation_name = FALSE
)

# Heatmap (igual estilo)
Heatmap(
  mat_block,
  name = "z-score",
  col = colorRamp2(c(-2,0,2), c("#4575b4","white","#d73027")),
  top_annotation = ha,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  row_names_side = "right",
  row_names_gp = gpar(fontsize = 7),
  show_column_names = FALSE,
  column_title = "Bloque de SNVs (z-score; todas las muestras)",
  use_raster = nrow(mat_block) > 400
) |> draw(heatmap_legend_side = "right")
```




```{r}
clean_block_df <- function(df_wide_heatmap, df_wide_vaf,
                           snvs_block_in_order = NULL,
                           pat_ALS  = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                           pat_CTRL = "(?i)control",
                           # umbrales (suaves) sobre z-score del HEATMAP
                           z_thr = 0.3,
                           min_frac_ALS = 0.10,
                           min_frac_all = 0.05,
                           min_mean_ALS = 0.15) {

  stopifnot("feature" %in% names(df_wide_heatmap),
            "feature" %in% names(df_wide_vaf))

  # 1) Subset a tu bloque (si lo pasas); si no, usa todas las filas del heatmap
  if (!is.null(snvs_block_in_order)) {
    keep_rows <- df_wide_heatmap$feature %in% snvs_block_in_order
  } else {
    keep_rows <- rep(TRUE, nrow(df_wide_heatmap))
  }
  H_sub <- df_wide_heatmap[keep_rows, , drop = FALSE]

  # 2) Matriz Z a partir del heatmap (lo que ves en el plot)
  feat <- H_sub$feature
  Z <- suppressWarnings(data.matrix(H_sub[ , setdiff(names(H_sub), "feature"), drop = FALSE]))
  rownames(Z) <- feat

  # 3) Máscaras de grupo por nombres de columna
  cn <- colnames(Z)
  is_ALS  <- grepl(pat_ALS,  cn, perl = TRUE)
  # is_CTRL <- grepl(pat_CTRL, cn, perl = TRUE)  # no es necesario para el filtro

  # 4) Métricas de representación (sobre Z)
  frac_ALS <- if (any(is_ALS))  rowMeans(Z[, is_ALS, drop = FALSE] > z_thr, na.rm = TRUE) else rep(0, nrow(Z))
  frac_all <- rowMeans(Z > z_thr, na.rm = TRUE)
  mean_ALS <- if (any(is_ALS))  rowMeans(pmax(Z[, is_ALS, drop = FALSE], 0), na.rm = TRUE) else rep(0, nrow(Z))

  stats <- tibble::tibble(
    feature   = feat,
    frac_ALS  = frac_ALS,
    frac_all  = frac_all,
    mean_ALS  = mean_ALS
  )

  # 5) Criterio de limpieza (idéntico a tu lógica)
  keep_ids <- stats$feature[
    (stats$frac_ALS >= min_frac_ALS | stats$frac_all >= min_frac_all) &
      (stats$mean_ALS >= min_mean_ALS)
  ]

  # 6) Aplicar el filtro a AMBOS DFs (mismo orden del HEATMAP)
  df_heatmap_clean <- df_wide_heatmap[df_wide_heatmap$feature %in% keep_ids, , drop = FALSE]
  df_vaf_clean     <- df_wide_vaf    [df_wide_vaf$feature     %in% keep_ids, , drop = FALSE]

  # ordenar VAF para que siga EXACTAMENTE el orden del heatmap
  ord <- match(df_heatmap_clean$feature, df_vaf_clean$feature)
  df_vaf_clean <- df_vaf_clean[ord, , drop = FALSE]

  # 7) Devolver todo lo útil
  list(
    df_heatmap_clean = df_heatmap_clean,  # z-score (wide) limpio
    df_vaf_clean     = df_vaf_clean,      # VAF (wide) sincronizado
    keep_snvs        = keep_ids,
    drop_snvs        = setdiff(feat, keep_ids),
    stats            = stats              # para inspección
  )
}
```


```{r}
cb2 <- clean_block_df(
  df_wide_heatmap = out$df_wide_heatmap,
  df_wide_vaf     = out$df_wide_vaf,
  snvs_block_in_order = snvs_block_in_order,  # o NULL si quieres evaluar todas las filas del heatmap
  pat_ALS  = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
  pat_CTRL = "(?i)control",
  z_thr = 0.3, min_frac_ALS = 0.10, min_frac_all = 0.05, min_mean_ALS = 0.15
)

# Resultados listos:
nrow(cb2$df_heatmap_clean); nrow(cb2$df_vaf_clean)
head(cb2$keep_snvs)
# readr::write_csv(cb2$df_heatmap_clean, "df_block_heatmap_clean.csv")
# readr::write_csv(cb2$df_vaf_clean,     "df_block_vaf_clean.csv")
```



```{r}
library(ComplexHeatmap)
library(circlize)
library(grid)
library(stringr)

# 1) Matriz del bloque LIMPIO en z-score (sale directo del heatmap limpio)
H <- cb2$df_heatmap_clean              # <- z-score (wide): feature + columnas
mat_block <- as.matrix(H[, -1, drop=FALSE])
rownames(mat_block) <- H$feature

# (opcional) ordenar columnas igual que el heatmap global si tienes 'out'
if (exists("out")) {
  cols_ord <- intersect(out$column_order_names, colnames(mat_block))
  mat_block <- mat_block[, cols_ord, drop = FALSE]
}

# 2) Anotación ALS / Control
pat_ALS  <- "(ALS[-_]enrolment|ALS[-_]longitudinal)"
pat_CTRL <- "(?i)control"
grp <- dplyr::case_when(
  str_detect(colnames(mat_block), pat_ALS)  ~ "ALS",
  str_detect(colnames(mat_block), pat_CTRL) ~ "Control",
  TRUE ~ "Other"
)
ha <- HeatmapAnnotation(
  Group = grp,
  col = list(Group = c("ALS"="#D62728","Control"="grey60","Other"="grey90")),
  show_annotation_name = FALSE
)

# 3) Heatmap (mismo esquema de color que usabas)
Heatmap(
  mat_block,
  name = "z-score",
  col  = colorRamp2(c(-2, 0, 2), c("#4575b4","white","#d73027")),
  top_annotation = ha,
  cluster_rows = TRUE,
  cluster_columns = TRUE,    # si prefieres mantener orden global, pon FALSE
  show_row_names = TRUE, row_names_side = "right", row_names_gp = gpar(fontsize = 7),
  show_column_names = FALSE,
  column_title = "top GT-SNVs in ALS (z-score; all samples)"
) |> draw(heatmap_legend_side = "right")
```




```{r}
# --- 1) Burden por muestra (z > 0.5) ---
Z <- as.matrix(cb2$df_heatmap_clean[,-1,drop=FALSE]); rownames(Z) <- cb2$df_heatmap_clean$feature
thr <- 0.5
burden <- colMeans(Z > thr, na.rm = TRUE)   # proporción de SNVs activos por muestra

# Comparación simple ALS vs Control
is_ALS  <- grepl("(ALS[-_]enrolment|ALS[-_]longitudinal)", names(burden), perl=TRUE)
is_CTRL <- grepl("(?i)control", names(burden), perl=TRUE)
t.test(burden[is_ALS], burden[is_CTRL])  # solo para ver señal

# --- 2) Tabla por SNV (prevalencia y efecto) ---
prev_ALS  <- if (any(is_ALS))  rowMeans(Z[,is_ALS,drop=FALSE]  > thr) else rep(0, nrow(Z))
prev_CTRL <- if (any(is_CTRL)) rowMeans(Z[,is_CTRL,drop=FALSE] > thr) else rep(0, nrow(Z))
d_mean    <- rowMeans(Z[,is_ALS,drop=FALSE]) - rowMeans(Z[,is_CTRL,drop=FALSE])

snv_stats <- data.frame(
  feature   = rownames(Z),
  prev_ALS, prev_CTRL,
  d_prev = prev_ALS - prev_CTRL,
  d_mean = d_mean,
  row.names = NULL
)
snv_stats_top <- snv_stats[order(-snv_stats$d_prev, -snv_stats$d_mean), ]
head(snv_stats_top, 20)

# --- 3) Mini-heatmap de los 15 más diferenciales ---
top15 <- snv_stats_top$feature[1:15]
mat15 <- Z[top15, , drop=FALSE]
library(ComplexHeatmap); library(circlize); library(grid)
grp <- ifelse(is_ALS, "ALS", ifelse(is_CTRL, "Control", "Other"))
ha  <- HeatmapAnnotation(Group = grp, col=list(Group=c(ALS="#D62728",Control="grey60",Other="grey90")))
Heatmap(mat15, name="z-score", col=colorRamp2(c(-2,0,2), c("#4575b4","white","#d73027")),
        top_annotation=ha, cluster_rows=TRUE, cluster_columns=TRUE,
        show_row_names=TRUE, row_names_side="right", row_names_gp=gpar(fontsize=8),
        show_column_names=FALSE, column_title="Top GT-SNVs (ALS vs control)") |>
  draw(heatmap_legend_side="right")

# --- 4) Resumen por familia / posición (si tus IDs son miRNA_pos_GT) ---
parts <- stringr::str_match(rownames(Z), "^(.*)_(\\d+)_GT$")
summ_family <- aggregate(rowMeans(Z > thr) ~ parts[,2], FUN=mean)
summ_pos    <- aggregate(rowMeans(Z > thr) ~ as.integer(parts[,3]), FUN=mean)
```
```{r}
# z-score (wide) en el mismo orden del heatmap
write_csv(cb2$df_heatmap_clean, "df_block_heatmap_clean.csv")

# VAF crudo 0..1 (wide) en el mismo orden
write_csv(cb2$df_vaf_clean, "df_block_vaf_clean.csv")
```




```{r}
library(dplyr); library(tidyr); library(stringr)
library(ComplexHeatmap); library(circlize); library(grid)
# Usa tus DFs limpios que salieron de clean_block_df()
V <- cb2$df_vaf_clean         # wide: feature + muestras (VAF 0..1)
Z <- cb2$df_heatmap_clean     # wide: feature + muestras (z-score por fila)

snvs_block <- Z$feature
mat_vaf <- as.matrix(V[match(snvs_block, V$feature), -1, drop=FALSE])
rownames(mat_vaf) <- snvs_block

mat_z   <- as.matrix(Z[, -1, drop=FALSE]); rownames(mat_z) <- snvs_block

# Grupos de columnas
pat_ALS  <- "(ALS[-_]enrolment|ALS[-_]longitudinal)"
pat_CTRL <- "(?i)control"
is_ALS   <- str_detect(colnames(mat_vaf), pat_ALS)
is_CTRL  <- str_detect(colnames(mat_vaf), pat_CTRL)
grp_lab  <- ifelse(is_ALS,"ALS", ifelse(is_CTRL,"Control","Other"))
```




```{r}
thr <- c("0.3%"=0.003, "0.5%"=0.005, "1%"=0.01)   # umbrales absolutos

prev_fun <- function(x, c) mean(x > c, na.rm=TRUE)

ALS_mean  <- rowMeans(mat_vaf[, is_ALS,  drop=FALSE], na.rm=TRUE)
CTRL_mean <- rowMeans(mat_vaf[, is_CTRL, drop=FALSE], na.rm=TRUE)
log2FC    <- log2((ALS_mean + 1e-5) / (CTRL_mean + 1e-5))

vaf_stats <- tibble(
  feature   = rownames(mat_vaf),
  ALS_mean  = ALS_mean,
  CTRL_mean = CTRL_mean,
  diff_mean = ALS_mean - CTRL_mean,
  log2FC    = log2FC,
  prev_ALS_0.3 = apply(mat_vaf[,is_ALS,drop=FALSE], 1, prev_fun, c=thr["0.3%"]),
  prev_CTL_0.3 = apply(mat_vaf[,is_CTRL,drop=FALSE],1, prev_fun, c=thr["0.3%"]),
  prev_ALS_0.5 = apply(mat_vaf[,is_ALS,drop=FALSE], 1, prev_fun, c=thr["0.5%"]),
  prev_CTL_0.5 = apply(mat_vaf[,is_CTRL,drop=FALSE],1, prev_fun, c=thr["0.5%"]),
  prev_ALS_1   = apply(mat_vaf[,is_ALS,drop=FALSE], 1, prev_fun, c=thr["1%"]),
  prev_CTL_1   = apply(mat_vaf[,is_CTRL,drop=FALSE],1, prev_fun, c=thr["1%"])
) %>%
  arrange(desc(diff_mean), desc(log2FC))

head(vaf_stats, 15)  # top por diferencia de media
# Si quieres CSV:
# readr::write_csv(vaf_stats, "vaf_stats_block.csv")
```
```{r}
cut <- 0.003  # 0.3%
burden_abs <- colMeans(mat_vaf > cut, na.rm=TRUE)  # fracción de SNVs del bloque activos
t.test(burden_abs[is_ALS], burden_abs[is_CTRL])    # contraste rápido ALS vs control
```























































```{r}
library(tidyverse)
library(ComplexHeatmap)
library(circlize)
library(scales)

# ---- Helpers ----
strip_suffix <- function(x) stringr::str_replace(x, "\\s*\\(PM\\+1MM\\+2MM\\)$", "")
label_group <- function(x, pat_ALS, pat_CTRL) case_when(
  stringr::str_detect(x, pat_ALS)  ~ "ALS",
  stringr::str_detect(x, pat_CTRL) ~ "CTRL",
  TRUE ~ "OTHER"
)

# 1) VAF y RPM (sin recortar a seed, sin filtro de cobertura)
compute_vaf_rpm <- function(df,
                            meta_cols = c("miRNA name","pos:mut"),
                            pat_ALS = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
                            pat_CTRL = "(?i)control") {
  stopifnot(all(meta_cols %in% colnames(df)))

  total_cols <- grep("\\(PM\\+1MM\\+2MM\\)$", colnames(df), value = TRUE)
  snv_cols   <- setdiff(colnames(df), c(meta_cols, total_cols))

  df_proc <- df %>%
    dplyr::rename(miRNA_name = `miRNA name`) %>%
    dplyr::mutate(
      pos = as.integer(stringr::str_extract(`pos:mut`, "^[0-9]+")),
      clean_mut = stringr::str_replace(`pos:mut`, ":", "_"),
      feature   = paste(miRNA_name, clean_mut, sep = "_")
    )
  # No filtramos a seed aquí.

  # Intersección SNV/TOT por muestra
  samples <- intersect(snv_cols, strip_suffix(total_cols))
  if (length(samples) == 0) stop("No hay intersección entre columnas SNV y TOT.")

  snv_use <- samples
  tot_use <- paste0(samples, " (PM+1MM+2MM)")

  snv_mat <- as.matrix(df_proc[, snv_use, drop = FALSE])
  tot_mat <- as.matrix(df_proc[, tot_use, drop = FALSE])

  # VAF sin umbral de cobertura
  vaf_mat <- snv_mat / pmax(tot_mat, 1)

  # Library size por muestra (suma TOT por miRNA, sin duplicar SNVs)
  libsize <- df_proc %>%
    dplyr::select(miRNA_name, dplyr::all_of(tot_use)) %>%
    dplyr::distinct(miRNA_name, .keep_all = TRUE) %>%
    dplyr::summarise(dplyr::across(dplyr::all_of(tot_use), ~ sum(.x, na.rm = TRUE)))
  Lj <- setNames(as.numeric(libsize[1, ]), samples)

  # RPM = SNV / Lj * 1e6
  rpm_mat <- sweep(snv_mat, 2, Lj[colnames(snv_mat)], "/") * 1e6
  rpm_mat[!is.finite(rpm_mat)] <- 0

  vaf_long <- df_proc %>%
    dplyr::select(feature, miRNA_name, pos) %>%
    dplyr::bind_cols(as_tibble(vaf_mat)) %>%
    tidyr::pivot_longer(cols = all_of(samples), names_to = "sample", values_to = "vaf") %>%
    dplyr::mutate(group = label_group(sample, pat_ALS, pat_CTRL)) %>%
    dplyr::filter(group %in% c("ALS","CTRL"))

  rpm_long <- df_proc %>%
    dplyr::select(feature, miRNA_name, pos) %>%
    dplyr::bind_cols(as_tibble(rpm_mat)) %>%
    tidyr::pivot_longer(cols = all_of(samples), names_to = "sample", values_to = "rpm") %>%
    dplyr::mutate(group = label_group(sample, pat_ALS, pat_CTRL)) %>%
    dplyr::filter(group %in% c("ALS","CTRL"))

  list(vaf_long = vaf_long, rpm_long = rpm_long, samples = samples)
}

# 2) Fracciones por posición (para seed vs resto)
make_pos_fractions_from_rpm <- function(rpm_long, pos_max = 23) {
  by_pos <- rpm_long %>%
    dplyr::filter(!is.na(pos), pos >= 1, pos <= pos_max) %>%
    dplyr::group_by(sample, group, pos) %>%
    dplyr::summarise(sum_rpm = sum(rpm, na.rm = TRUE), .groups = "drop")

  totals <- by_pos %>%
    dplyr::group_by(sample, group) %>%
    dplyr::summarise(total_rpm = sum(sum_rpm, na.rm = TRUE), .groups = "drop")

  frac_pos <- by_pos %>%
    dplyr::left_join(totals, by = c("sample","group")) %>%
    dplyr::mutate(frac = dplyr::if_else(total_rpm > 0, sum_rpm / total_rpm, NA_real_)) %>%
    tidyr::drop_na(frac)

  seed_by_sample <- frac_pos %>%
    dplyr::mutate(in_seed = pos >= 2 & pos <= 7) %>%
    dplyr::group_by(sample, group, in_seed) %>%
    dplyr::summarise(frac_sum = sum(frac), .groups = "drop") %>%
    tidyr::pivot_wider(names_from = in_seed, values_from = frac_sum, values_fill = 0) %>%
    dplyr::rename(frac_nonseed = `FALSE`, frac_seed = `TRUE`) %>%
    dplyr::mutate(seed_fraction = frac_seed)

  list(frac_pos = frac_pos, seed_by_sample = seed_by_sample)
}

# 3) Tests
test_seed_fraction <- function(seed_by_sample) {
  list(
    wilcox  = wilcox.test(seed_fraction ~ group, data = seed_by_sample, exact = FALSE),
    summary = seed_by_sample %>% group_by(group) %>%
      summarise(n = dplyr::n(),
                mean = mean(seed_fraction), median = median(seed_fraction),
                .groups = "drop")
  )
}
test_by_position <- function(frac_pos) {
  frac_pos %>%
    group_by(pos) %>%
    summarise(
      p = tryCatch(wilcox.test(frac ~ group, data = cur_data(), exact = FALSE)$p.value,
                   error = function(e) NA_real_),
      mean_ALS  = mean(frac[group=="ALS"],  na.rm = TRUE),
      mean_CTRL = mean(frac[group=="CTRL"], na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(p_adj = p.adjust(p, "BH"), delta = mean_ALS - mean_CTRL)
}

# 4) Plots (IMPRIMEN)
plot_seed_fraction <- function(seed_by_sample, title = "Seed fraction per sample") {
  ggplot(seed_by_sample, aes(group, seed_fraction, fill = group)) +
    geom_violin(width = 0.9, alpha = 0.35, color = NA) +
    geom_boxplot(width = 0.25, outlier.shape = NA) +
    geom_jitter(width = 0.08, alpha = 0.6, size = 1.8) +
    scale_fill_manual(values = c("CTRL"="grey60","ALS"="#D62728")) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    labs(x = NULL, y = "Fraction of G>T in seed (2–7)", title = title) +
    theme_classic(base_size = 13)
}
plot_pos_bars_presence <- function(tests_df,
                                   title = "G>T positional fraction — ALS vs CTRL") {
  plot_df <- tests_df %>%
    select(pos, mean_CTRL, mean_ALS, p_adj) %>%
    pivot_longer(c(mean_CTRL, mean_ALS), names_to = "group", values_to = "mean_frac") %>%
    mutate(group = recode(group, mean_CTRL = "CTRL", mean_ALS = "ALS"))
  ymax <- max(plot_df$mean_frac, na.rm = TRUE) * 1.1

  ggplot(plot_df, aes(pos, mean_frac, fill = group)) +
    annotate("rect", xmin = 2 - 0.5, xmax = 7 + 0.5, ymin = 0, ymax = ymax,
             fill = "grey80", alpha = 0.3) +
    geom_col(position = position_dodge(width = 0.8), width = 0.7) +
    geom_text(
      data = subset(plot_df, group == "ALS" &
                      p_adj[match(pos, unique(pos))] < 0.05),
      aes(label = "*"),
      position = position_nudge(x = 0.2), vjust = -0.5, size = 5
    ) +
    scale_x_continuous(breaks = 1:23) +
    scale_fill_manual(values = c("CTRL"="grey60","ALS"="#D62728")) +
    scale_y_continuous(labels = percent_format(accuracy = 1)) +
    labs(x = "Position", y = "Mean fraction within sample",
         fill = NULL, title = title,
         subtitle = "Seed shaded; asterisks at FDR < 0.05") +
    coord_cartesian(ylim = c(0, ymax)) +
    theme_classic(base_size = 13)
}
```

```{r}
# Usa tu df filtrado: top miRNAs, solo G>T, sin PM
res <- compute_vaf_rpm(
  df_gt,
  meta_cols = c("miRNA name","pos:mut"),
  pat_ALS   = "(ALS[-_]enrolment|ALS[-_]longitudinal)",
  pat_CTRL  = "(?i)control"
)

parts  <- make_pos_fractions_from_rpm(res$rpm_long, pos_max = 23)
seed_t <- test_seed_fraction(parts$seed_by_sample)
pos_t  <- test_by_position(parts$frac_pos)

# Imprimir gráficos (no guarda)
plot_seed_fraction(parts$seed_by_sample)
plot_pos_bars_presence(pos_t)

# Números rápidos:
seed_t$summary      # medias/medianas y n por grupo
seed_t$wilcox$p.value
pos_t %>% arrange(p_adj) %>% head()
```







































```{r}
snp_expanded  <- split_mutations(df_filtered, mut_col = "pos:mut")
snp_collapsed <- collapse_after_split(snp_expanded, mut_col = "pos:mut")
```

```{r}
snp_collapsed
```

```{r}

# 1) Pivot de los totales (denominador)
tot_long <- snp_collapsed %>%
  select(miRNA_name, `pos:mut`, all_of(total_cols)) %>%
  pivot_longer(
    cols      = all_of(total_cols),
    names_to  = "sample",
    values_to = "total"
  ) %>%
  mutate(
    sample = str_remove(sample, fixed(" (PM+1MM+2MM)"))
  )

# 2) Pivot de los SNV counts (numerador)
count_long <- snp_collapsed %>%
  select(miRNA_name, `pos:mut`, all_of(snv_cols)) %>%
  pivot_longer(
    cols      = all_of(snv_cols),
    names_to  = "sample",
    values_to = "count"
  ) %>%
  mutate(
    sample = str_remove(sample, fixed(" (PM+1MM+2MM)"))
  )

# 3) Left join para juntar total + count por fila
freq_df <- left_join(
  count_long,
  tot_long,
  by = c("miRNA_name", "pos:mut", "sample")
) %>%
  # 4) añadimos grupo (si quieres)
  mutate(
    group = sample_info_clean$group[match(sample, sample_info_clean$sample)]
  ) %>%
  select(miRNA_name, `pos:mut`, sample, total, count, group)

# Comprueba
head(freq_df)
```

```{r}
head(snp_collapsed)
```

```{r}
# 1) Long de totales (denominador)
tot_long <- snp_filt %>%
  pivot_longer(
    cols      = all_of(total_cols),
    names_to  = "sample",
    values_to = "total"
  ) %>%
  mutate(
    sample = str_remove(sample, fixed(" (PM+1MM+2MM)"))
  )

# 2) Long de SNV counts (numerador)
snv_long <- snp_collapsed %>%
  pivot_longer(
    cols      = all_of(snv_cols),
    names_to  = "sample",
    values_to = "count"
  ) %>%
  mutate(
    sample = str_remove(sample, fixed(" (PM+1MM+2MM)"))
  )

# 3) Unir ambos y calcular frecuencia
freq_df <- left_join(
  snv_long,
  tot_long,
  by = c("miRNA_name","pos:mut","sample")
) %>%
  mutate(
    freq  = count / total,
    group = sample_info_clean$group[match(sample, sample_info_clean$sample)]
  )

# 4) Comprueba
head(freq_df)
```

```{r}
dim(snp_collapsed)
length(total_cols)
length(snv_cols)
```

```{r}

# 1) Filtrar snp_collapsed: conservar solo filas con >1 count en ≥5 muestras
snp_filt <- snp_collapsed %>%
  filter(
    rowSums(across(all_of(snv_cols), ~ .x > 1)) >= 5
  )

# Comprueba cuántas filas quedan:
cat("Variants retained:", nrow(snp_filt),
    "of original", nrow(snp_collapsed), "\n")
```

```{r}

```

------------\>

```{r}

# ----------------- 2  tabla de medias por grupo ----------------
pm_long <- annotate_total_counts(df, cols = total_cols) %>%         # PM sólo
  pivot_longer(-miRNA, names_to = "sample_raw", values_to = "count") %>%
  mutate(sample = str_remove(sample_raw, fixed("(PM+1MM+2MM)"))) %>%
  left_join(sample_info_clean, by = "sample")

mean_tbl <- pm_long %>%
  group_by(group, miRNA) %>%
  summarise(mean_count = mean(count), .groups = "drop") %>%
  filter(miRNA %in% miRNA_union)

# consistent palette
group_cols <- c("ALS-Enrolment"    = "#F8766D",
                "ALS-Longitudinal" = "#00BA38",
                "Control"          = "#619CFF")

```

```{r}
# ----------------- 3  Diagrama Euler (todas las listas) --------
library(eulerr)
venn_sets <- setNames(miRNAs_by_group$miRNAs_keep,
                      miRNAs_by_group$group)

fit <- euler(venn_sets)

plot(
  fit,
  quantities = TRUE,
  fills      = list(fill = group_cols[names(venn_sets)], alpha = .5),
  edges      = TRUE,
  labels     = FALSE,    # we’ll add titles below
  legend     = TRUE
) 
```

```{r}
library(dplyr)

# 2-A  find the global top-10
global_top <- mean_tbl %>%
  group_by(miRNA) %>%
  summarise(global_mean = mean(mean_count), .groups = "drop") %>%
  slice_max(global_mean, n = 10, with_ties = FALSE)

plot_dfA <- mean_tbl %>%
  semi_join(global_top, by = "miRNA") %>%      # keep only those miRNAs
  left_join(global_top,  by = "miRNA")         # brings in global_mean for ordering

# 2-B  barplot (three bars per miRNA)
ggplot(plot_dfA,
       aes(x = reorder(miRNA, -global_mean),
           y = mean_count,
           fill = group)) +
  geom_col(position = "dodge", width = .8) +
  scale_fill_manual(values = group_cols) +
  labs(title = "Top-10 globally most abundant miRNAs",
       x     = "miRNA (ordered by global mean)",
       y     = "Mean PM counts") +
  coord_flip() +
  theme_minimal(base_size = 11)

```

```{r}
top_n <- 10
library(purrr)

# 3-A  list of top-n miRNAs per group
top_list <- mean_tbl %>%
  group_by(group) %>%
  slice_max(mean_count, n = top_n, with_ties = FALSE) %>%
  group_split()

names(top_list) <- vapply(top_list, function(x) unique(x$group), character(1))

# 3-B  plotting function
plot_topN <- function(top_tbl, title_group) {

  miRNA_order <- top_tbl %>%
    arrange(desc(mean_count)) %>%
    pull(miRNA)

  df <- mean_tbl %>%
    filter(miRNA %in% miRNA_order) %>%
    mutate(miRNA = factor(miRNA, levels = miRNA_order))

  ggplot(df,
         aes(x = miRNA, y = mean_count, fill = group)) +
    geom_col(position = "dodge", width = .8) +
    scale_fill_manual(values = group_cols) +
    labs(title = paste0("Top-", top_n, " miRNAs in ", title_group),
         x = NULL, y = "Mean PM counts") +
    coord_flip() + theme_minimal(base_size = 11)
}

# 3-C  generate the three plots
p_top_enr  <- plot_topN(top_list$`ALS-Enrolment`,    "ALS-Enrolment")
p_top_long <- plot_topN(top_list$`ALS-Longitudinal`, "ALS-Longitudinal")
p_top_ctl  <- plot_topN(top_list$Control,           "Control")


print(p_top_enr)
print(p_top_ctl)
print(p_top_long)
```

```{r}
library(ggVennDiagram)

# 1) Build the three character vectors
top10_sets <- list(
  `ALS-Enrolment`    = top_list$`ALS-Enrolment`$miRNA,
  `ALS-Longitudinal` = top_list$`ALS-Longitudinal`$miRNA,
  Control            = top_list$Control$miRNA
)

# 2) Euler / Venn (same group colours)
fit_top <- euler(top10_sets)

plot(
  fit_top,
  quantities = TRUE,                       # show counts
  fills      = list(fill = group_cols[names(top10_sets)],
                    alpha = .55),
  edges      = TRUE,
  adjust_labels = TRUE,
  legend     = TRUE,
  main = "Overlap of Top-10 miRNAs for each group"
)
```

```{r}

# top10_sets was created earlier
miRNA_30 <- unique(unlist(top10_sets))      # union of the 3 × 10 lists

plot_df <- mean_tbl %>%                     # mean_tbl = PM means per group
  filter(miRNA %in% miRNA_30) %>%           # keep only those 30 miRNAs
  group_by(miRNA) %>%                       # order by global mean
  mutate(global_mean = mean(mean_count)) %>%
  ungroup()

# order miRNAs left-to-right by decreasing global mean
plot_df$miRNA <- factor(plot_df$miRNA,
                        levels = plot_df %>%
                                 distinct(miRNA, global_mean) %>%
                                 arrange(desc(global_mean)) %>%
                                 pull(miRNA))
```

```{r}
group_cols <- c("ALS-Enrolment"    = "#F8766D",
                "ALS-Longitudinal" = "#00BA38",
                "Control"          = "#619CFF")

ggplot(plot_df,
       aes(x = miRNA,
           y = group,
           size  = mean_count,
           fill  = group)) +
  geom_point(shape = 21, colour = "black", alpha = 0.8) +
  scale_size_continuous(name = "Mean PM\ncounts",
                        range = c(2, 12),
                        breaks = scales::breaks_pretty(4)) +
  scale_fill_manual(values = group_cols, guide = "none") +
  labs(title = "Distribution of Top-10 miRNAs (union = 30) across groups",
       x = NULL, y = NULL) +
  coord_flip() +                              # miRNAs vertically
  theme_minimal(base_size = 11) +
  theme(axis.text.y  = element_text(size = 9),
        axis.text.x  = element_text(size = 10, face = "bold"),
        plot.title   = element_text(hjust = .5, face = "bold"))
```

```{r}
heat_df <- plot_df %>%
  mutate(log10_mean = log10(mean_count + 1))

ggplot(heat_df,
       aes(x = miRNA, y = group, fill = log10_mean)) +
  geom_tile(colour = "grey80") +
  scale_fill_viridis_c(option = "B", name = "log10 mean\ncounts") +
  coord_flip() +
  labs(title = "Heat-map of Top-10 miRNAs (union = 30)") +
  theme_minimal(base_size = 11) +
  theme(axis.text.y  = element_text(size = 9),
        axis.text.x  = element_text(size = 10, face = "bold"),
        plot.title   = element_text(hjust = .5, face = "bold"))
```

```{r}
snv_df
```

```{r}
pm_long 

```

```{r}
group_top_tbl
```

```{r}
sample_info_clean

```

```{r}
snv_df
```

------------------------------------------------------------------------

```{r}
library(ggvenn)
# ------------------------------------------------------------
# PARTE 2: Total Counts por Muestra y Por Grupo (Boxplot/Violin)
# ------------------------------------------------------------

# 2.0) PREPARAR una versión “limpia” de sample_info_tot quitando el sufijo:
sample_info_clean <- sample_info_tot %>%
  # sample_info_tot$sample original trae el sufijo "(PM+1MM+2MM)"
  mutate(
    sample = str_remove(sample, fixed("(PM+1MM+2MM)")) %>% str_trim()
  ) %>%
  select(sample, group)

# Verifica (opcional):
# head(sample_info_clean)
# unique(sample_info_clean$sample)


tot_long_filt <- df_rpm_filtered %>%
  annotate_total_counts(
    cols      = total_cols,
    miRNA_col = "miRNA name",
    mut_col   = "pos:mut"
  ) %>%
  pivot_longer(
    cols      = -miRNA,
    names_to  = "sample_raw",
    values_to = "total_count"
  ) %>%
  mutate(
    sample = str_remove(sample_raw, fixed("(PM+1MM+2MM)")) %>% str_trim()
  ) %>%
  select(miRNA, sample, total_count)

tot_long_filt2 <- tot_long_filt %>%
  left_join(sample_info_clean, by = "sample") %>%
  filter(!is.na(group))

# ------------------------------------------------------------
# PARTE 2) Gráfico A: Distribución de total_count por grupo
#             (Violin + Boxplot, con eje Y log10 y recorte de outliers)
# ------------------------------------------------------------
p1 <- ggplot(tot_long_filt2, aes(x = group, y = total_count, fill = group)) +
  geom_violin(trim = FALSE, alpha = 0.4, color = NA) +
  geom_boxplot(
    width = 0.15,
    outlier.shape = NA,
    alpha = 0.6,
    color = "darkgray"
  ) +
  stat_summary(
    fun    = median,
    geom   = "point",
    shape  = 23,
    size   = 2,
    fill   = "yellow",
    color  = "black"
  ) +
  scale_y_log10(
    labels = comma_format(accuracy = 1),
    breaks = c(10, 100, 1e3, 1e4, 1e5, 1e6, 1e7)
  ) +
  coord_cartesian(ylim = c(5, 1e7)) +
  labs(
    title = "Total Counts per miRNA by Sample Group",
    x     = "",
    y     = "Total Count (log10 scale)"
  ) +
  scale_fill_manual(
    values = c(
      "ALS-Enrolment"    = "#F8766D",
      "ALS-Longitudinal" = "#7CAE00",
      "Control"          = "#00BFC4"
    )
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position   = "none",
    axis.text.x       = element_text(size = 12, face = "bold"),
    axis.title.y      = element_text(size = 12, face = "bold"),
    plot.title        = element_text(size = 14, face = "bold", hjust = 0.5)
  )

print(p1)



# ------------------------------------------------------------
# PARTE 3) Gráfico B: “Average Expression per miRNA” (Violin + Boxplot)
#             usando avg_total_count de table_totals_filt
# ------------------------------------------------------------

table_totals_filt <- tot_long_filt2 %>%
  group_by(group, miRNA) %>%
  summarise(
    avg_total_count = mean(total_count, na.rm = TRUE),
    .groups         = "drop"
  )

p2 <- ggplot(table_totals_filt, aes(x = group, y = avg_total_count, fill = group)) +
  geom_violin(trim = FALSE, alpha = 0.4, color = NA) +
  geom_boxplot(
    width = 0.15,
    outlier.shape = NA,
    alpha = 0.6,
    color = "darkgray"
  ) +
  stat_summary(
    fun    = median,
    geom   = "point",
    shape  = 23,
    size   = 2,
    fill   = "white",
    color  = "black"
  ) +
  scale_y_log10(
    labels = comma_format(accuracy = 1),
    breaks = c(10, 100, 1e3, 1e4, 1e5, 1e6)
  ) +
  coord_cartesian(ylim = c(5, 1e6)) +
  labs(
    title = "Average miRNA Expression (Total Counts) by Group",
    x     = "",
    y     = "Average Total Count (log10 scale)"
  ) +
  scale_fill_manual(
    values = c(
      "ALS-Enrolment"    = "#F8766D",
      "ALS-Longitudinal" = "#7CAE00",
      "Control"          = "#00BFC4"
    )
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position   = "none",
    axis.text.x       = element_text(size = 12, face = "bold"),
    axis.title.y      = element_text(size = 12, face = "bold"),
    plot.title        = element_text(size = 14, face = "bold", hjust = 0.5)
  )

print(p2)



# ------------------------------------------------------------
# PARTE 4) Gráfico C: Diagrama de Venn (Top miRNAs por grupo)
# ------------------------------------------------------------

# Extraer los mismos vectores que antes:
top_n <- 103
top_miRNAs_list <- table_totals_filt %>%
  group_by(group) %>%
  arrange(desc(avg_total_count)) %>%
  slice_head(n = top_n) %>%
  ungroup() %>%
  group_by(group) %>%
  summarise(top_miRNAs = list(miRNA), .groups = "drop")

miRNAs_ALS_Enrolment    <- top_miRNAs_list %>%
  filter(group == "ALS-Enrolment") %>%
  pull(top_miRNAs) %>% .[[1]]
miRNAs_ALS_Longitudinal <- top_miRNAs_list %>%
  filter(group == "ALS-Longitudinal") %>%
  pull(top_miRNAs) %>% .[[1]]
miRNAs_Control          <- top_miRNAs_list %>%
  filter(group == "Control") %>%
  pull(top_miRNAs) %>% .[[1]]

# Preparar lista para ggvenn
venn_input <- list(
  "ALS-Enrolment"    = miRNAs_ALS_Enrolment,
  "ALS-Longitudinal" = miRNAs_ALS_Longitudinal,
  "Control"          = miRNAs_Control
)

p3 <- ggvenn(
  venn_input,
  fill_color    = c("#F8766D", "#7CAE00", "#00BFC4"),
  stroke_size   = 0.5,
  set_name_size = 6,
  text_size     = 4,
  show_percentage = FALSE
) +
  ggtitle("Overlap of miRNAs by Group") +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    legend.position = "none"
  )

print(p3)


# ------------------------------------------------------------
# PARTE 5) Gráfico D: Medianas de Average miRNA Expression por Grupo
# ------------------------------------------------------------
median_totals_by_group <- table_totals_filt %>%
  group_by(group) %>%
  summarise(
    median_avg = median(avg_total_count, na.rm = TRUE),
    .groups    = "drop"
  )

p4 <- ggplot(median_totals_by_group, aes(x = group, y = median_avg, fill = group)) +
  geom_col(alpha = 0.6) +
  geom_text(
    aes(label = comma(median_avg, accuracy = 1)),
    vjust = -0.5,
    size  = 4,
    color = "black"
  ) +
  scale_y_continuous(
    labels = comma_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.1))
  ) +
  labs(
    title = "Median of Average miRNA Expression by Group",
    x     = "",
    y     = "Median Average Total Count"
  ) +
  scale_fill_manual(
    values = c(
      "ALS-Enrolment"    = "#F8766D",
      "ALS-Longitudinal" = "#7CAE00",
      "Control"          = "#00BFC4"
    )
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "none",
    axis.text.x     = element_text(size = 12, face = "bold"),
    axis.title.y    = element_text(size = 12, face = "bold"),
    plot.title      = element_text(size = 14, face = "bold", hjust = 0.5)
  )

print(p4)
```

```{r}

# 1) Totales en formato largo ------------------------------------------------
tot_long <- df_rpm_filtered %>%
  annotate_total_counts() %>%          # filas PM
  pivot_longer(
    cols      = -miRNA,
    names_to  = "sample_raw",
    values_to = "total_count"
  ) %>%
  mutate(
    sample = sample_raw %>%
               str_remove(fixed("(PM+1MM+2MM)")) %>%
               str_trim()
  )
# head(tot_long); glimpse(tot_long); summary(tot_long$total_count)

# 2) avg_total_count y n_samples_present ------------------------------------
table_totals <- tot_long %>%
  # 2a) Unir grupo
  left_join(
    sample_info_tot    %>% rename(sample_raw = sample),
    by = "sample_raw"
  ) %>%
  # 2b) Agrupar y resumir
  group_by(group, miRNA) %>%
  summarise(
    avg_total_count   = mean(total_count, na.rm = TRUE),
    n_samples_present = sum(total_count > 0),
    .groups           = "drop"
  )
# head(table_totals)

# 3.1) SNV en formato largo --------------------------------------------------
snv_long <- df_rpm_filtered %>%
  annotate_snv_presence() %>%          # solo mutaciones
  pivot_longer(
    cols      = all_of(snv_cols),
    names_to  = "sample_raw",
    values_to = "count"
  ) %>%
  filter(count > 0) %>%      #aquí importa que son las que tienen cuentas mayores a cero
  mutate(
    sample = sample_raw %>%
               str_remove(fixed("(PM+1MM+2MM)")) %>%    ##aquí no es necesario esto, porq son snvs
               str_trim()
  ) %>%
  select(miRNA,mut, sample, count)
# glimpse(snv_long); summary(snv_long$count)

# 3.2) snv_count y snv_freq por muestra --------------------------------------
snv_counts <- snv_long %>%
  group_by(miRNA,mut, sample) %>%
  summarise(snv_count = sum(count), .groups = "drop")


snv_per_sample <- snv_counts %>%
  left_join(
    tot_long %>% select(miRNA, sample, total_count),
    by = c("miRNA","sample")
  ) %>%
  mutate(
    snv_freq_sample   = (snv_count / total_count) * 100,
    snv_count_sample  = snv_count                # <-- guardamos snv_count “tal cual”
  )

# 3.3) avg_snv_freq por grupo–miRNA -----------------------------------------

snv_per_sample_collapsed <- snv_per_sample %>%
  group_by(miRNA, sample) %>%
  summarise(
    # ①: suma de todas las frecuencias puntuales (método clásico)
    snv_freq_sum      = sum(snv_freq_sample, na.rm = TRUE),
    # ②: guardamos total_count para esa muestra
    total_count       = first(total_count),
    # ③: suma de las cuentas absolutas de SNV en esa muestra
    snv_count_sum     = sum(snv_count_sample, na.rm = TRUE),
    .groups           = "drop"
  )


# 2) Necesitamos asegurarnos de incluir todas las muestras, incluso aquellas
#    de un (miRNA, sample) donde no hubo SNV (snv_freq_sum = 0).
#    Para ello tomamos el listado completo de (miRNA, sample) que existe en tot_long.
all_miRNA_samples <- tot_long %>%
  select(miRNA, sample) %>%
  distinct()


# 3) Unimos esa lista completa con los valores que acabamos de colapsar.
#    Las filas que no existían en "snv_per_sample_collapsed" pasan a snv_freq_sum = 0
snv_per_sample_complete <- all_miRNA_samples %>%
  left_join(snv_per_sample_collapsed, by = c("miRNA", "sample")) %>%
  replace_na(list(
    snv_freq_sum  = 0,
    total_count   = 0,
    snv_count_sum = 0
  ))

# 4) Crea una tabla "sample_info_clean" que asocie cada muestra a su grupo
#    (tal cual lo hacías antes). Asegúrate de que aquí aparezcan todas las muestras
#    que vas a usar (si faltara alguna, no se incluirá en el resumen final).
sample_info_clean <- snv_per_sample_complete %>%
  distinct(sample) %>%
  mutate(group = case_when(
    str_detect(sample, "ALS[-_]longitudinal") ~ "ALS-Longitudinal",
    str_detect(sample, "ALS[-_]enrolment")    ~ "ALS-Enrolment",
    TRUE                                      ~ "Control"
  ))


# 5) Ahora sí, agrupamos por (group, miRNA). Pero en lugar de sumar
#    las fracciones de SNV puntuales, trabajamos con el valor único
#    "snv_freq_sum" por muestra, y promediamos esas sumas entre todas las
#    muestras del grupo (incluyendo las que quedaron con snv_freq_sum = 0).
# —— 5A) MÉTODO “Clásico”: promedio de frecuencias de muestra (snv_freq_sum) ——————————
snv_summary_by_miRNA_classic <- snv_per_sample_complete %>%
  left_join(sample_info_clean, by = "sample") %>%
  filter(!is.na(group)) %>%
  group_by(group, miRNA) %>%
  summarise(
    avg_snv_freq_classic  = mean(snv_freq_sum, na.rm = TRUE),
    sd_snv_freq_classic   = ifelse(n() > 1, sd(snv_freq_sum, na.rm = TRUE), NA_real_),
    min_snv_freq_classic  = min(snv_freq_sum, na.rm = TRUE),
    max_snv_freq_classic  = max(snv_freq_sum, na.rm = TRUE),
    n_samps_classic       = n(),
    .groups               = "drop"
  )

# —— 5B) MÉTODO “Total‐based”: frecuencia a nivel de suma de conteos ——————————————
snv_summary_by_miRNA_total <- snv_per_sample_complete %>%
  left_join(sample_info_clean, by = "sample") %>%
  filter(!is.na(group)) %>%
  group_by(group, miRNA) %>%
  summarise(
    sum_snv_counts_group   = sum(snv_count_sum,   na.rm = TRUE),
    sum_total_counts_group = sum(total_count,     na.rm = TRUE),
    .groups                = "drop"
  ) %>%
  mutate(
    freq_snv_group = ifelse(
      sum_total_counts_group > 0,
      (sum_snv_counts_group / sum_total_counts_group) * 100,
      0
    )
  )

```

```{r}
gt_snv_long <- snp_collapsed%>%
  # a) Quedarnos con columnas de metadatos + columnas de conteo SNV:
  select(
    `miRNA name`,
    `pos:mut`,
    all_of(snv_cols)
  ) %>%
  # b) Primero renombramos para que split_mutations se entienda:
  rename(miRNA = `miRNA name`, mut = `pos:mut`) %>%
  # c) Separar filas donde `mut` estaba como “2:GA,12:GT” en múltiples filas:
  split_mutations(mut_col = "mut") %>%
  # d) Ahora colapsamos sumando los conteos (por cada mutación puntual):
  collapse_after_split(mut_col = "mut", count_cols = snv_cols) %>%
  # e) Filtrar solo las mutaciones cuyo sufijo sea “GT”:
  filter(str_detect(mut, "GT$")) %>%
  # f) Renombrar “miRNA_name” → “miRNA” para homogeneidad con el resto:
  rename(miRNA = miRNA_name)


snv_long_gt <- gt_snv_long %>%
  pivot_longer(
    cols      = all_of(snv_cols),
    names_to  = "sample_raw",
    values_to = "count"
  ) %>%
  filter(count > 0) %>%
  mutate(
    sample = sample_raw %>%
               str_remove(fixed("(PM+1MM+2MM)")) %>%  # en principio no tienen sufijo, pero por consistencia
               str_trim()
  ) %>%
  select(miRNA, mut, sample, count)

# 3.2.2) Agrupar por (miRNA, mut, sample) para asegurarnos de no tener duplicados
snv_counts_gt <- snv_long_gt %>%
  group_by(miRNA, mut, sample) %>%
  summarise(snv_count = sum(count), .groups = "drop")

# 3.2.3) Unir con tot_long para sacar total_count y calcular snv_freq (0-100)
snv_per_sample_gt <- snv_counts_gt %>%
  left_join(
    tot_long %>% select(miRNA, sample, total_count),
    by = c("miRNA", "sample")
  ) %>%
  mutate(
    # Multiplicamos por 100 para tener porcentaje
    snv_freq = (snv_count / total_count) * 100
  )
# head(snv_per_sample_gt); summary(snv_per_sample_gt$snv_freq)

# 3.3) avg_snv_freq por grupo–miRNA (solo para GT)
#
# a) Colapsar por (miRNA, sample): sumar todas las fracciones de G→T en cada muestra
snv_per_sample_collapsed_gt <- snv_per_sample_gt %>%
  group_by(miRNA, sample) %>%
  summarise(
    # Si hubiera más de una mutación G→T en esa muestra, las sumamos.
    gt_snv_freq_sum = sum(snv_freq, na.rm = TRUE),
    total_count     = first(total_count),
    .groups         = "drop"
  )

# b) Asegurarnos de incluir todas las muestras (si no tuvieron G→T, poner 0)
all_miRNA_samples <- tot_long %>%
  select(miRNA, sample) %>%
  distinct()

snv_per_sample_collapsed_gt_fixed <- snv_per_sample_gt %>%
  group_by(miRNA, sample) %>%
  summarise(
    gt_snv_total_count = sum(snv_count, na.rm = TRUE),
    total_count        = first(total_count),
    .groups            = "drop"
  ) %>%
  mutate(
    # Calculamos el porcentaje total de GT en esa muestra
    gt_snv_freq_sum = (gt_snv_total_count / total_count) * 100
  )
# Ahora en snv_per_sample_collapsed_gt_fixed$gt_snv_freq_sum nunca puede pasar de 100.


# 2) Asegurarnos de incluir todas las muestras (si no hubo G→T, poner lecturas mutadas = 0)
all_miRNA_samples <- tot_long %>%
  select(miRNA, sample) %>%
  distinct()

snv_per_sample_complete_gt_fixed <- all_miRNA_samples %>%
  left_join(snv_per_sample_collapsed_gt_fixed, by = c("miRNA", "sample")) %>%
  # Llenamos con 0 aquellas filas que no tenían ninguna lectura mutada
  replace_na(list(
    gt_snv_total_count = 0,
    total_count        = 0,
    gt_snv_freq_sum    = 0
  ))


# 3) Re-construir sample_info_clean (idéntico a antes)
sample_info_clean_gt <- snv_per_sample_complete_gt_fixed %>%
  distinct(sample) %>%
  mutate(
    group = case_when(
      str_detect(sample, "ALS[-_]longitudinal") ~ "ALS-Longitudinal",
      str_detect(sample, "ALS[-_]enrolment")    ~ "ALS-Enrolment",
      TRUE                                      ~ "Control"
    )
  )


# 4) Volver a generar 'gt_summary_by_SNV', ahora con la frecuencia corregida
snv_summary_by_SNV_fixed <- snv_per_sample_gt %>%
  left_join(sample_info_clean_gt, by = "sample") %>%
  filter(!is.na(group)) %>%
  group_by(group, miRNA, mut) %>%
  summarise(
    avg_snv_freq = mean(snv_freq, na.rm = TRUE),       # sigue presente, no cambia
    # Pero volvamos a calcular el “promedio de la fracción total G→T”:
    # Para ello, nos valdremos de 'snv_per_sample_collapsed_gt_fixed'
    # Entonces, mejor volvemos a unir y calcular desde allí:

    .groups = "drop"
  )

# 1.1) Unir con grupo y agrupar por (group, miRNA, mut)
snv_summary_by_SNV <- snv_per_sample_gt %>%
  left_join(sample_info_clean_gt, by = "sample") %>%  # agregar la columna `group`
  filter(!is.na(group)) %>%                          # en caso de que alguna muestra no tuviera grupo
  group_by(group, miRNA, mut) %>%
  summarise(
    # Para cada SNV puntual, calculamos el promedio de su snv_freq sobre todas las muestras del grupo
    avg_snv_freq = mean(snv_freq, na.rm = TRUE),
    sd_snv_freq  = ifelse(n() > 1, sd(snv_freq, na.rm = TRUE), NA_real_),
    min_snv_freq = min(snv_freq, na.rm = TRUE),
    max_snv_freq = max(snv_freq, na.rm = TRUE),
    n_samps      = n(),      # cuántas muestras del grupo tuvieron ese SNV
    .groups      = "drop"
  )
```

```{r}
top_n_snv <- 50

# 2.1) Tomamos solo las filas con group == "ALS-Enrolment"
snv_als_enrol <- snv_summary_by_SNV %>%
  filter(group == "ALS-Enrolment")

# 2.2) Ordenamos descendiendo por avg_snv_freq y tomamos los primeros 50
top_SNVs <- snv_als_enrol %>%
  arrange(desc(avg_snv_freq)) %>%
  slice_head(n = top_n_snv) %>%
  # Creamos un ID único para cada mutación, concatenando miRNA y mut
  mutate(snv_id = paste(miRNA, mut, sep = ":")) %>%
  pull(snv_id)

# Mira qué SNVs quedaron seleccionados
length(top_SNVs)   # debe ser 50
head(top_SNVs, 10)
```

```{r}
# 3.1) En el data frame de resumen “snv_summary_by_SNV”, creamos una columna `snv_id`
snv_summary_wide_prep <- snv_summary_by_SNV %>%
  mutate(snv_id = paste(miRNA, mut, sep = ":")) %>%
  select(group, snv_id, avg_snv_freq)

# 3.2) Filtramos solo los SNVs que están en top_SNVs
snv_summary_top <- snv_summary_wide_prep %>%
  filter(snv_id %in% top_SNVs)

# 3.3) Pivotamos a formato ancho:
#      - filas = snv_id
#      - columnas = valores únicos de “group”
#      - celdas = avg_snv_freq
snv_heatmap_df <- snv_summary_top %>%
  pivot_wider(
    names_from  = group,
    values_from = avg_snv_freq,
    values_fill = 0   # si un SNV no aparece en un grupo, ponemos 0
  )

# Verifica la tabla resultante:
#   snv_id                   ALS-Enrolment  ALS-Longitudinal  Control
#   "hsa-miR-21-5p:9:GT"         45.3             10.2           0.0
#   "hsa-let-7a-3p:12:GT"        38.7             5.1            1.4
#   …
print(head(snv_heatmap_df, 10))
glimpse(snv_heatmap_df)

# 3.4) Convertir a matriz (rownames = snv_id, colnames = grupos)
heatmap_mat <- snv_heatmap_df %>%
  column_to_rownames("snv_id") %>%
  as.matrix()

# Comprueba dimensiones y rangos
dim(heatmap_mat)        # 50 filas × 3 columnas
range(heatmap_mat)      # debería estar entre 0 y ≤100
```

```{r}
pheatmap(
  heatmap_mat,
  cluster_rows = TRUE,         # agrupar SNVs por patrón de frecuencias
  cluster_cols = FALSE,        # columnas fijas: ALS-Enrolment, ALS-Longitudinal, Control
  scale        = "none",       # no reescalar, usar los valores 0–100 directamente
  color        = colorRampPalette(c("lightblue","white","firebrick3"))(50),
  fontsize_row = 6,
  fontsize_col = 10,
  labels_col   = c("ALS-Enrolment", "ALS-Longitudinal", "Control"),
  main         = "Heatmap of Average G→T SNV Frequency\n(Top 50 SNVs in ALS-Enrolment)",
  border_color = NA
)
```

```{r}
# Partimos de snv_summary_by_SNV, que debe tener estas columnas:
#   group            (factor con valores "ALS-Enrolment", "ALS-Longitudinal", "Control")
#   miRNA            (ej. "hsa-miR-21-5p")
#   mut              (ej. "9:GT")
#   avg_snv_freq     (promedio de snv_freq en %, ya en 0–100)
#   sd_snv_freq, etc. (no los usamos aquí)

# 1) Creamos el identificador único "snv_id" = "miRNA:mut" y pivotamos a formato ancho:
snv_wide <- snv_summary_by_SNV %>%
  mutate(snv_id = paste(miRNA, mut, sep = ":")) %>%
  select(group, snv_id, avg_snv_freq) %>%
  pivot_wider(
    names_from  = group,
    values_from = avg_snv_freq,
    values_fill = 0
  )
# Ahora snv_wide tiene columnas:
#   snv_id               | ALS-Enrolment | ALS-Longitudinal | Control
#   "hsa-miR-21-5p:9:GT" |        12.3   |          5.2     |   3.4
#   "hsa-let-7a-3p:12:GT"|         8.7   |          4.1     |   2.0
#   …

# 2) Filtramos para quedarnos solo con los SNVs que TENGAN ≤ 15% **en cada uno** de los tres grupos:
snv_wide_filtered <- snv_wide %>%
  filter(
    `ALS-Enrolment`    <= 1.5,
    `ALS-Longitudinal` <= 1.5,
    Control            <= 1.5
  )
# Ahora ninguna fila de snv_wide_filtered supera 15 en ninguna de las columnas.


# 3) De ese conjunto, seleccionamos los “top 50” basándonos solo en la columna ALS-Enrolment:
top_n_snv <- 50

top_SNVs <- snv_wide_filtered %>%
  arrange(desc(`ALS-Longitudinal`)) %>%   # ordenar por ALS-Enrolment descendente
  slice_head(n = top_n_snv) %>%        # quedarnos con las primeras 50 filas
  pull(snv_id)                         # extraer el vector de identificadores "snv_id"

length(top_SNVs)    # Debe ser 50 (o menos si había < 50 SNVs que cumplieran ≤15 en todos)
head(top_SNVs, 10)  # Mira los primeros 10 identificadores


# 4) Construir la matriz final para el heatmap, usando solo esos top_SNVs:
snv_heatmap_df <- snv_wide_filtered %>%
  filter(snv_id %in% top_SNVs) %>%   # quedarnos únicamente con los 50 seleccionados
  column_to_rownames("snv_id") %>%   # mover snv_id a los rownames
  select(`ALS-Enrolment`, `ALS-Longitudinal`, Control)  # columnas en el orden deseado

heatmap_mat <- as.matrix(snv_heatmap_df)
# Verificamos que efectivamente todos los valores estén en [0, 15]:
range(heatmap_mat[, "ALS-Enrolment"])
range(heatmap_mat[, "ALS-Longitudinal"])
range(heatmap_mat[, "Control"])


# 5) Dibujar el heatmap con la escala ajustada a 0–15 (automáticamente usa 0–máx = 0–15):
# Generamos un vector de 50 tonos que va de blanco a “firebrick3”
single_palette <- colorRampPalette(c("white", "firebrick3"))(50)

pheatmap(
  heatmap_mat,
  cluster_rows  = TRUE,
  cluster_cols  = FALSE,
  scale         = "none",
  color         = single_palette,          # Usamos solo la paleta blanco→firebrick3
  fontsize_row  = 6,
  fontsize_col  = 10,
  labels_col    = c("ALS-Enrolment", "ALS-Longitudinal", "Control"),
  main          = "Heatmap of Average G→T SNV Frequency\n(Top 50 SNVs ≤20% in ALS-Longitudinal )",
  border_color  = NA
)
```

```{r}
# 3) Extraer los Top 50 de cada grupo ALS ------------------------
top_n <- 50

top_enrol <- snv_wide_filtered %>%
  arrange(desc(`ALS-Enrolment`)) %>%
  slice_head(n = top_n) %>%
  pull(snv_id)

top_long <- snv_wide_filtered %>%
  arrange(desc(`ALS-Longitudinal`)) %>%
  slice_head(n = top_n) %>%
  pull(snv_id)

# 4) Intersección: SNVs comunes a ambos Top-50 --------------------
common_SNVs <- intersect(top_enrol, top_long)
cat("SNVs en Top", top_n, "de ambos grupos ALS:", length(common_SNVs), "\n")

# 5) Preparar la matriz para el heatmap --------------------------
heatmap_mat <- snv_wide_filtered %>%
  filter(snv_id %in% common_SNVs) %>%
  select(snv_id, `ALS-Enrolment`, `ALS-Longitudinal`, Control) %>%
  column_to_rownames("snv_id") %>%
  as.matrix()

# 6) Dibujar heatmap ---------------------------------------------
# Creamos paleta blanco → rojo
single_palette <- colorRampPalette(c("white", "firebrick3"))(50)
valor_top <- max(heatmap_mat, na.rm = TRUE)

pheatmap(
  heatmap_mat,
  cluster_rows  = TRUE,
  cluster_cols  = FALSE,
  scale         = "none",
  color         = single_palette,
  breaks        = seq(0, valor_top, length.out = length(single_palette) + 1),
  fontsize_row  = 6,
  fontsize_col  = 10,
  labels_col    = c("ALS-Enrolment", "ALS-Longitudinal", "Control"),
  main          = paste0(
                     "Heatmap of G→T SNV Frequency\n",
                     length(common_SNVs),
                     " SNVs in Top ", top_n,
                     " of both ALS groups (cutoff ≤10%)"
                   ),
  border_color  = NA
)

# 7) Revisar resultados clave -------------------------------------
snv_wide_filtered %>%
  filter(snv_id %in% common_SNVs) %>%
  arrange(desc(`ALS-Enrolment`)) %>%
  print(n = Inf)
```

```{r}
# 1) Partimos de snv_summary_by_SNV, que tiene:
#    group, miRNA, mut, avg_snv_freq

# 2) Estadísticas descriptivas por grupo ------------------------------
snv_group_stats <- snv_summary_by_SNV %>%
  group_by(group) %>%
  summarise(
    mean_freq   = mean(avg_snv_freq, na.rm = TRUE),
    median_freq = median(avg_snv_freq, na.rm = TRUE),
    sd_freq     = sd(avg_snv_freq, na.rm = TRUE),
    max_freq    = max(avg_snv_freq, na.rm = TRUE),
    n_SNVs      = n(),
    .groups     = "drop"
  )

print(snv_group_stats)

# 3) Gráfica de la distribución de avg_snv_freq por grupo -------------
p_dist <- ggplot(snv_summary_by_SNV, aes(x = group, y = avg_snv_freq, fill = group)) +
  geom_violin(trim = FALSE, alpha = 0.5) +
  geom_boxplot(width = 0.2, outlier.shape = NA, alpha = 0.7) +
  stat_summary(fun = median, geom = "point", shape = 23, size = 2, fill = "white") +
  scale_y_continuous(name = "Average G→T Frequency (%)") +
  labs(
    title = "Distribution of G→T SNV Frequency by Group",
    x     = "Group"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

print(p_dist)
```

```{r}
# Dentro de tu pipeline, mete algo así para debugging:
test <- snv_per_sample_gt %>%
  filter(miRNA == "hsa-miR-21-5p", mut == "9:GT", sample == "Muestra42")
print(test$snv_count)
print( tot_long %>% filter(miRNA=="hsa-miR-21-5p", sample=="Muestra42") %>% pull(total_count) )
```

Aquí vamos a partir el notebook

```{r}
snv_summary_by_SNV <- snv_per_sample_gt %>%
  # 2.1) Unir la información de grupo a cada fila
  left_join(sample_info_clean_gt, by = "sample") %>%
  filter(!is.na(group)) %>%      # descartamos por si alguna muestra no tenía grupo
  
  # 2.2) Agrupar por (group, miRNA, mut) y calcular estadísticas de snv_freq
  group_by(group, miRNA, mut) %>%
  summarise(
    avg_snv_freq = mean(snv_freq, na.rm = TRUE),
    sd_snv_freq  = ifelse(n() > 1, sd(snv_freq, na.rm = TRUE), NA_real_),
    min_snv_freq = min(snv_freq, na.rm = TRUE),
    max_snv_freq = max(snv_freq, na.rm = TRUE),
    n_samps      = n(),              # cuántas muestras aportaron datos de ese SNV en este grupo
    .groups      = "drop"
  )

# Ahora `snv_summary_by_SNV` tiene columnas:
#   group | miRNA | mut   | avg_snv_freq | sd_snv_freq | min_snv_freq | max_snv_freq | n_samps

# Ejemplo de las primeras filas:
print(head(snv_summary_by_SNV, 10))
glimpse(snv_summary_by_SNV)


#### 3) Seleccionar los "top SNVs" en ALS-Enrolment ####
# Queremos, por ejemplo, quedarnos con las 50 mutaciones G→T con mayor avg_snv_freq
# dentro de "ALS-Enrolment". Ajusta `top_n_snv` a tu gusto.

```

```{r}
top_n_snv <- 100

top_SNVs <- snv_summary_by_SNV %>%
  filter(group == "ALS-Enrolment") %>%          # solo filas de ALS-Enrolment
  arrange(desc(avg_snv_freq)) %>%                # de mayor a menor frecuencia
  slice_head(n = top_n_snv) %>%                  # tomamos las primeras 50
  mutate(snv_id = paste(miRNA, mut, sep = ":")) %>%  # concatenamos para un ID único
  pull(snv_id)                                   # extraemos ese vector de identificadores

# Ejemplo: cada elemento de top_SNVs podría ser algo como "hsa-miR-21-5p:9:GT"
length(top_SNVs)  # debería ser 50


#### 4) Construir la matriz ancha (miRNA:mut × grupo) con avg_snv_freq ####

# 4.1) Añadimos una columna “snv_id” para poder pivotar más fácilmente:
snv_summary_wide_prep <- snv_summary_by_SNV %>%
  mutate(snv_id = paste(miRNA, mut, sep = ":")) %>%
  select(group, snv_id, avg_snv_freq)

# 4.2) Filtrar solo los SNVs seleccionados en top_SNVs:
snv_summary_top <- snv_summary_wide_prep %>%
  filter(snv_id %in% top_SNVs)

# 4.3) Pivotar a formato ancho donde:
#      - filas = snv_id
#      - columnas = group
#      - celda = avg_snv_freq (rellenar con 0 donde no exista)
snv_heatmap_df <- snv_summary_top %>%
  pivot_wider(
    names_from  = group,
    values_from = avg_snv_freq,
    values_fill = 0
  )

# Ejemplo de `snv_heatmap_df`:
#   snv_id                     | ALS-Enrolment | ALS-Longitudinal | Control
#   "hsa-miR-21-5p:9:GT"       |  25.3         | 10.7            |  2.4
#   "hsa-let-7a-3p:12:GT"      |  18.1         |  5.2            |  1.1
#   "hsa-miR-584-5p:3:GT"      |  15.6         |  7.8            |  0.0
#   …

# 4.4) Convertir a matriz con rownames = snv_id
heatmap_mat <- snv_heatmap_df %>%
  column_to_rownames("snv_id") %>%
  as.matrix()

# Ahora `heatmap_mat` es una matriz de dimensión (top_n_snv × 3),
# filas = SNVs seleccionados, columnas = 3 grupos, valores = avg_snv_freq (0–100).


#### 5) Dibujar el heatmap de SNVs ####

library(pheatmap)

pheatmap(
  heatmap_mat,
  cluster_rows = TRUE,      # agrupa las mutaciones puntuales según su patrón en los grupos
  cluster_cols = FALSE,     # deja el orden fijo: ALS-Enrolment, ALS-Longitudinal, Control
  scale        = "none",    # no reescala los valores: usamos 0–100 tal cual
  fontsize_row = 6,         # ajusta tamaño de fuente en filas para leer bien
  fontsize_col = 10,
  main         = "Heatmap of Mean G→T SNV Frequency (Top 100 SNVs in ALS-Enrolment)",
  border_color = NA
)
```

## Chunk 7: Bubble plots by group (in English, formatted axes)

```{r chunk7_bubble_plots_en, warning=FALSE, message=FALSE}


for (grp in unique(final_summary$group)) {
  dfp <- final_summary %>% filter(group == grp)
  
  p <- ggplot(dfp, aes(
      x     = n_samples_present,
      y     = avg_total_count,
      size  = avg_snv_freq,
      color = avg_GT_freq
    )) +
    geom_point(alpha = 0.7) +
    scale_x_continuous(
      breaks = pretty_breaks(n = 5)
    ) +
    scale_y_continuous(
      labels = comma,                # comma-formatted y-axis
      breaks = pretty_breaks(n = 5)
    ) +
    scale_size_area(
      max_size = 12,
      guide    = guide_legend(
        title = "Mean SNV\nfrequency",
        override.aes = list(alpha = 1)
      )
    ) +
    scale_color_gradient(
      low   = "lightblue",
      high  = "red",
      guide = guide_colorbar(
        title = "Mean G→T\nfrequency",
        barwidth = unit(0.5, "cm"),
        barheight = unit(5, "cm")
      )
    ) +
    labs(
      title = paste("Bubble Plot –", grp),
      x     = "# Samples with SNV",
      y     = "Mean total count",
      caption = "Bubble size ∝ SNV freq, color ∝ G→T freq"
    ) +
    theme_minimal() +
    theme(
      plot.title      = element_text(face = "bold", hjust = 0.5),
      axis.title      = element_text(size = 12),
      axis.text       = element_text(size = 10),
      legend.title    = element_text(size = 10),
      legend.text     = element_text(size = 9),
      legend.position = "right",
      plot.margin     = margin(5, 5, 5, 5)
    )
  
  print(p)
}
```

```{r}
library(ggrepel)

for (grp in unique(final_summary$group)) {
  dfp <- final_summary %>% filter(group == grp)
  
  # 1) pick top 5 G→T
  top_gt5 <- dfp %>%
    arrange(desc(avg_GT_freq)) %>%
    slice_head(n = 5)

  p <- ggplot(dfp, aes(
      x     = n_samples_present,
      y     = avg_total_count,
      size  = avg_snv_freq,
      color = avg_GT_freq
    )) +
    geom_point(alpha = 0.7) +
    
    # 2) annotate those top 5
    geom_text_repel(
      data            = top_gt5,
      aes(label = miRNA),
      size            = 3,
      box.padding     = 0.3,
      point.padding   = 0.2,
      segment.color   = "grey50"
    ) +
    
    scale_x_continuous(breaks = scales::pretty_breaks(5)) +
    scale_y_continuous(
      labels = scales::comma,
      breaks = scales::pretty_breaks(5)
    ) +
    scale_size_area(
      max_size = 12,
      guide    = guide_legend(title = "Mean SNV\nfrequency")
    ) +
    scale_color_gradient(
      low   = "lightblue",
      high  = "red",
      guide = guide_colorbar(title = "Mean G→T\nfrequency")
    ) +
    labs(
      title   = paste("Bubble Plot –", grp),
      x       = "# Samples with SNV",
      y       = "Mean total count",
      caption = "Bubble size ∝ SNV freq, color ∝ G→T freq"
    ) +
    theme_minimal(base_size = 12) +
    theme(
      plot.title    = element_text(face = "bold", hjust = 0.5),
      legend.position = "right"
    )
  
  print(p)
}
```

```{r}

# Ejemplo para avg_GT_freq
tops <- final_summary %>%
  group_by(group) %>%
  slice_max(avg_GT_freq, n=20) %>%
  pull(miRNA) %>% unique()

mat <- final_summary %>%
  filter(miRNA %in% tops) %>%
  select(group, miRNA, avg_GT_freq) %>%
  pivot_wider(names_from=group, values_from=avg_GT_freq, values_fill=0) %>%
  column_to_rownames("miRNA") %>%
  as.matrix()

pheatmap(mat,
         cluster_rows = TRUE,
         cluster_cols = FALSE,
         main = "Heatmap of Mean G→T freq (top miRNAs)")
```

```{r}
# how many samples total?
n_samps <- length(total_cols)
cat("Total samples:", n_samps, "\n")

# binary matrix of RPM ≥1
bt <- binary_threshold(rpm_df, threshold=1, min_fraction=0)$binary_matrix 
# count, for each miRNA, in how many samples RPM>=1
rpm_hits <- bt %>% 
  mutate(n_hits = rowSums(select(., -miRNA))) %>%
  select(miRNA, n_hits)

summary(rpm_hits$n_hits)
head(rpm_hits %>% arrange(desc(n_hits)), 10)
```

## Chunk 8: Apply filters and re‐run summaries + plots on filtered data

```{r chunk8_filters_and_plots, message=FALSE, warning=FALSE}
# 1) Start from your PM counts and calculate RPM
rpm_df <- df %>%
  annotate_total_counts() %>%            # keep only PM rows
  calculate_RPM()                        # normalize to reads per million

# quick sanity check
print(head(rpm_df))
summary(rpm_df %>% select(-miRNA))

# 2) Now run your binary threshold: RPM ≥ 1 in at least X% of samples
#    let’s start very permissively with min_fraction = 0 (i.e. we only require >=1 RPM in ≥1 sample)
bt <- binary_threshold(rpm_df,
                       threshold    = 1,
                       min_fraction = 0)

# bt is a list:
#  bt$binary_matrix   :   0/1 matrix of miRNA × samples
#  bt$selected_miRNAs :   vector of all miRNAs that had RPM ≥1 in ≥0% of samples,
#                        i.e. essentially all of them as long as they ever hit 1

length(bt$selected_miRNAs)
head(bt$selected_miRNAs, 20)

```

```{r}
# 1) Build the count‐per‐million (RPM) data frame ----------------------------

# first get the raw PM counts in wide form
pm_wide <- df %>%
  annotate_total_counts()       # this gives you a tibble miRNA × total_cols

# then compute the RPM normalization
rpm_df <- pm_wide %>% 
  calculate_RPM()               # uses your calculate_RPM() function

# inspect
rpm_df %>% glimpse()
rpm_df %>% summary()

# 2) Apply binary thresholding ----------------------------------------------

# let’s say you want RPM ≥ 1 in at least 10% of samples
bt <- binary_threshold(rpm_df,
                       threshold    = 1,
                       min_fraction = 0.10)

# this returns a list: 
#  - bt$binary_matrix is a miRNA×sample matrix of 0/1 calls
#  - bt$selected_miRNAs is the character vector of miRNAs that pass

length(bt$selected_miRNAs)  # how many pass globally

# 3) Count survivors per group ----------------------------------------------

# turn your binary matrix into a long tibble, join sample→group, then count
library(tidyr)

survivors_per_group <- bt$binary_matrix %>%
  pivot_longer(-miRNA, names_to="sample", values_to="present") %>%
  filter(present == 1) %>%
  left_join(sample_info_tot, by="sample") %>%   # brings in `group`
  count(group) %>%
  rename(n_miRNAs = n)

survivors_per_group
```
