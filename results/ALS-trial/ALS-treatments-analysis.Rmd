---
title: "ALS-miRNA-Dash_Banaja-apr22"
author: "César Esparza"
date: "2025-04-22"
output: html_document
---

```{r}
install.packages("rlang")
```


```{r}
install.packages("stringr")
install.packages("janitor")
install.packages("limma")


if (!requireNamespace("DESeq2", quietly=TRUE)) {
  BiocManager::install("DESeq2")
}


if (!requireNamespace("edgeR", quietly=TRUE)) {
  BiocManager::install("edgeR")
}

```

```{r}
library(rlang)
library(stringr)
library(tidyverse)
library(janitor)
library(DESeq2)
library(limma)
library(edgeR)
```



```{r}
# 1. Leer y limpiar nombres de columna -----------------------------
# ¿Por qué? Normalizar todos los nombres (reemplaza espacios, ":" y paréntesis).
df_raw <- read_tsv("/Users/cesaresparza/New_Desktop/UCSD/8OG/results/ALS-trial/miRNA_count.Q38.txt") %>%
  clean_names()
# Ahora la columna "pos:mut" es "pos_mut", y los totales "(PM+1MM+2MM)" son 
# p.ej. "trimmed_sod1_als_ipsc_..._1_pm_1mm_2mm".

colnames(df_raw)
```
```{r}
# 2.1. Crear un nuevo data.frame solo con las SNVs (quitando los PM)
df_snv <- df_raw %>%
  filter(pos_mut != "PM")

# 2.2. Verificación rápida:  
#     ¿Cuántas filas teníamos en el raw y cuántas quedan?
n_raw <- nrow(df_raw)
n_snv <- nrow(df_snv)
message("Filas totales: ", n_raw, 
        " → Filas sin PM: ", n_snv,
        " (eliminadas: ", n_raw - n_snv, ")")
```


```{r}
split_mutations <- function(df, mut_col = "pos_mut") {
  col_sym <- sym(mut_col)
  df %>% 
    separate_rows(!!col_sym, sep = ",") %>% 
    mutate(!!col_sym := str_trim(!!col_sym))
}

df_snv_split <- split_mutations(df_snv, "pos_mut")

# 4. Verificar resultado --------------------------------------------
#   Cada mutación múltiple p.e. "11:GT,22:TA" → dos filas separadas
df_snv_split %>% 
  filter(str_detect(pos_mut, ",")) %>% 
  nrow()   # debe dar 0

df_snv_split %>% 
  filter(mi_rna_name == "hsa-let-7a-3p") %>% 
  head()

```


```{r}
collapse_mutations <- function(df, mut_col = "pos_mut") {
  # 4.1. Identificar columnas de conteo puro (excluyendo totales PM+1MM+2MM)
  count_cols <- df %>% 
    select(starts_with("trimmed_")) %>% 
    select(-ends_with("_pm_1mm_2mm")) %>% 
    names()
  
  # 4.2. Agrupar por miRNA + mutación (posición:mut) y sumar los reads
  df %>%
    group_by(mi_rna_name, !!sym(mut_col)) %>%
    summarise(across(all_of(count_cols), sum), .groups = "drop") 
}

# Aplicar al df_snv_split (resultado de split_mutations)
df_collapsed <- collapse_mutations(df_snv_split, "pos_mut")

# 4.3. Verificación rápida
#   Comprueba que, para un mismo miRNA y pos_mut, haya solo una fila:
df_collapsed %>%
  filter(mi_rna_name == "hsa-let-7a-3p", pos_mut %in% c("8:AG","18:TC")) %>%
  print()

```


```{r}
df_collapsed
```
```{r}
# 1) Define las columnas de conteo puro:
count_cols <- df_collapsed %>%
  select(starts_with("trimmed_")) %>%
  select(-ends_with("_pm_1mm_2mm")) %>%
  names()
```


```{r}
# 2) Genera featureID y construye la matriz:
df_DE <- df_collapsed %>%
  mutate(
    pos_mut   = str_replace_all(pos_mut, ":", "_"),
    featureID = paste(mi_rna_name, pos_mut, sep = "_")
  ) %>%
  select(featureID, all_of(count_cols)) %>%
  column_to_rownames("featureID")

count_mat <- as.matrix(df_DE)


# 4) Forzar integer (requisito de edgeR)
mode(count_mat) <- "integer"

# Verifica que existe y no tiene NAs:
stopifnot(exists("count_mat"))
stopifnot(!any(is.na(count_mat)))

cat("Dimensions of count_mat:", dim(count_mat), 
    "(rows = variants, cols = samples)\n")
```


```{r}
sample_table <- tibble(sample = colnames(count_mat)) %>%
  mutate(
    # 1) genotype: busca “control”, “tdp43” o “sod1” dentro del nombre
    genotype = str_extract(sample, "(control|tdp43|sod1)"),
    # 2) rep: toma el dígito o dígitos finales tras el último "_"
    rep      = as.integer(str_extract(sample, "(?<=_)([0-9]+)$"))
  ) %>%
  # 3) convierto genotype a factor en el orden de los niveles
  mutate(genotype = factor(genotype,
                           levels = c("control", "tdp43", "sod1")))


# Verificación
print(sample_table)
print(table(sample_table$genotype))
```

```{r}
# ——————  Filtrar variantes outliers antes de armar el DGEList ——————
# 1) Calculo la suma de counts por variante (rowSums sobre count_mat)
variant_sums <- rowSums(count_mat)

# 2) Defino el umbral: p.ej. percentil 99
cutoff <- quantile(variant_sums, probs = 0.95)

# 3) Reporto cuántas variantes elimino
n_out <- sum(variant_sums > cutoff)
cat("Eliminando", n_out, "variantes (", 
    round(100 * n_out/length(variant_sums),1), 
    "%) con total >", round(cutoff,1), "lecturas\n")

# 4) Subconjunto el count_mat
keep_vars  <- names(variant_sums)[variant_sums <= cutoff]
count_mat   <- count_mat[keep_vars, , drop = FALSE]
```


```{r}
dge <- DGEList(counts = count_mat, samples = sample_table)
```


```{r}
# Requerimos al menos 0.5 CPM en al menos 2 muestras
keep <- filterByExpr(dge,
                     group = dge$samples$genotype,
                     min.count = 2,      # mínimo raw count en alguna muestra
                     min.mem = 0.5)      # mínimo CPM
dge  <- dge[keep, , keep.lib.sizes = FALSE]
cat("Después de filtrar:", nrow(dge), "variantes quedan\n")
```

```{r}
# Chunk I ─── Normalizar librerías (TMM)
dge <- calcNormFactors(dge, method = "TMM")
# Chequeo de factores
dge$samples$norm.factors
```

```{r}
# Chunk J ─── Diseño y estimación de dispersiones (robusto)
design <- model.matrix(~ 0 + genotype, data = dge$samples)
colnames(design) <- levels(dge$samples$genotype)

dge <- estimateDisp(dge,
                    design,
                    robust = TRUE)   # robust contra outliers
plotBCV(dge)                # inspección visual
```


```{r}
# Chunk K ─── Ajuste QL y pruebas de contraste
fit <- glmQLFit(dge, design, robust = TRUE)

# Ejemplo: compara SOD1 vs control
contrast_sod1_vs_ctrl <- makeContrasts(sod1 - control,
                                       levels = design)
qlf1 <- glmQLFTest(fit, contrast = contrast_sod1_vs_ctrl)
top1 <- topTags(qlf1, n = 20)
print(top1)

# Otro contraste: TDP43 vs control
contrast_tdp43_vs_ctrl <- makeContrasts(tdp43 - control,
                                        levels = design)
qlf2 <- glmQLFTest(fit, contrast = contrast_tdp43_vs_ctrl)
top2 <- topTags(qlf2, n = 20)
print(top2)
```


```{r}
library(tibble)

df_long <- as.data.frame(dge$counts) %>%
  rownames_to_column("featureID") %>%  
  pivot_longer(-featureID,
               names_to  = "sample",
               values_to = "count") %>%
  # 1.2 Pego metadata de muestras
  left_join(dge$samples, by = c("sample"="sample")) %>%
  # 1.3 Extraigo posición y el cambio de featureID
  separate(featureID,
           into = c("miRNA","pos_mut"),
           sep   = "_(?=[0-9]+_[ACGT]{2,2}$)",  # lookahead para la última parte
           remove = FALSE) %>%
  separate(pos_mut,
           into = c("position","change"),
           sep = "_",
           convert = TRUE)
```




```{r heatmap_processing}
library(dplyr)
library(tidyr)

# 1) Sumar los reads por variant×position
df_tot <- df_long %>%
  group_by(featureID, position) %>%
  summarise(total = sum(count), .groups="drop") %>%
  mutate(position = as.integer(position))

# 2) Elegir Top100 y Bottom100 según el total global
variant_totals <- df_tot %>%
  group_by(featureID) %>%
  summarise(overall = sum(total), .groups="drop") %>%
  arrange(desc(overall))

sel_top <- variant_totals$featureID[1:100]
sel_bot <- tail(variant_totals$featureID, 100)

# 3) Preparar df_main, df_top, df_bot con factores ordenados
feature_order <- variant_totals$featureID

df_main <- df_tot %>%
  mutate(featureID = factor(featureID, levels = feature_order))

df_top <- df_main %>%
  filter(featureID %in% sel_top) %>%
  mutate(featureID = factor(featureID, levels = sel_top))

df_bot <- df_main %>%
  filter(featureID %in% sel_bot) %>%
  mutate(featureID = factor(featureID, levels = sel_bot))

# 4) Calcular máximo para la escala de color (ej. max de total)
max_tot <- ceiling(max(df_main$total))

# 5) Definir la escala white→red con límites adaptados
red_scale <- scale_fill_gradient(
  low      = "white",
  high     = "#CD0000",
  limits   = c(0, max_tot),
  breaks   = seq(0, max_tot, length.out = 6),
  labels   = scales::comma(seq(0, max_tot, length.out = 6)),
  name     = "Reads"
)
```

```{r}
# 1) ¿Cómo viene tu df_long?
#    Mira las primeras filas y el rango de posiciones y counts
head(df_long)
summary(df_long$count)
table(df_long$position)

# 2) Verifica df_tot
head(df_tot)
summary(df_tot$total)
table(df_tot$position)

# 3) Revisa variant_totals
head(variant_totals)
tail(variant_totals)
summary(variant_totals$overall)

# 4) Confirma los subconjuntos Top/Bottom
length(sel_top); head(sel_top)
length(sel_bot); head(sel_bot)
```
```{r}
library(ggplot2)
library(patchwork)

# — Main heatmap (todas las variantes) —
p_main <- ggplot(df_main, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(y = paste0("SNVs (n = ", length(levels(df_main$featureID)), ")"),
       x = NULL) +
  theme_minimal(base_size = 10) +
  theme(
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid   = element_blank(),
    plot.margin  = margin(5,5,5,5)
  )

# — Inset Top100 —
p_top <- ggplot(df_top, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(title = "Top 100") +
  theme_minimal(base_size = 10) +
  theme(
    axis.text   = element_blank(),
    axis.ticks  = element_blank(),
    panel.grid  = element_blank(),
    plot.title  = element_text(color = "#CD0000", size = 12, face = "bold"),
    plot.margin = margin(5,5,5,5)
  )

# — Inset Bottom100 —
p_bot <- ggplot(df_bot, aes(x = position, y = featureID, fill = total)) +
  geom_tile() +
  geom_vline(xintercept = c(2,6), linetype="dashed", color="grey50") +
  red_scale +
  scale_x_continuous(breaks = c(1,6,12,18,22), expand = c(0,0)) +
  labs(title = "Bottom") +
  theme_minimal(base_size = 10) +
  theme(
    axis.text   = element_blank(),
    axis.ticks  = element_blank(),
    panel.grid  = element_blank(),
    plot.title  = element_text(color = "grey50", size = 12, face = "bold"),
    plot.margin = margin(5,5,5,5)
  )

# — Ensamble con patchwork y titulación —
(p_main | (p_top / p_bot)) +
  plot_layout(widths = c(3,1), guides = "collect") +
  plot_annotation(
    title    = expression(underline("miRNA_seq")),
    subtitle = "1    Position    22"
  ) &
  theme(
    plot.title      = element_text(size=16, face="bold", hjust=0.5),
    plot.subtitle   = element_text(size=14, hjust=0.5),
    legend.position = "right"
  )

nrow(df_main)
```





```{r}

library(dplyr)

# 1) Agrupar por posición y tipo de cambio, sumar lecturas
df_prop <- df_long %>%
  group_by(position, change) %>%
  summarise(count = sum(count), .groups="drop") %>%
  # 2) Dentro de cada posición, calcular total y proporción
  group_by(position) %>%
  mutate(
    total_pos = sum(count),
    prop      = count / total_pos
  ) %>%
  ungroup()

# Vista rápida
head(df_prop)
# Opcional: ver proporciones en posición 2–6 vs fuera de semilla
df_prop %>%
  mutate(region = if_else(position %in% 2:6, "seed", "outside_seed")) %>%
  group_by(region, change) %>%
  summarise(mean_prop = mean(prop)) 
```


```{r}
library(ggplot2)

ggplot(df_prop, aes(x = position, y = prop, color = change)) +
  geom_line(size = 1) +
  # Opcional: puntos para reforzar posiciones discretas
  geom_point(size = 1) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(
    x     = "Position",
    y     = "read change proportion",
    color = "mutation",
    title = "mutation distribution along the miRNA"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    legend.position = "bottom",
    panel.grid.minor = element_blank()
  )
```

